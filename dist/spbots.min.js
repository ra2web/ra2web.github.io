/*! For license information please see spbots.js.LICENSE.txt */
define("SPBots",["@chronodivide/game-api","three"],((t,e)=>(()=>{var i={436:(t,e,i)=>{const{Heap:s}=i(613),{MinHeap:r}=i(573),{MaxHeap:n}=i(945);e.Heap=s,e.MinHeap=r,e.MaxHeap=n},613:(t,e)=>{class i{constructor(t,e,i){if("function"!=typeof t)throw new Error("Heap constructor expects a compare function");this._compare=t,this._nodes=Array.isArray(e)?e:[],this._leaf=i||null}toArray(){return Array.from(this._nodes)}_hasLeftChild(t){return 2*t+1<this.size()}_hasRightChild(t){return 2*t+2<this.size()}_compareAt(t,e){return this._compare(this._nodes[t],this._nodes[e])}_swap(t,e){const i=this._nodes[t];this._nodes[t]=this._nodes[e],this._nodes[e]=i}_shouldSwap(t,e){return!(t<0||t>=this.size())&&!(e<0||e>=this.size())&&this._compareAt(t,e)>0}_compareChildrenOf(t){if(!this._hasLeftChild(t)&&!this._hasRightChild(t))return-1;const e=2*t+1,i=2*t+2;return this._hasLeftChild(t)?this._hasRightChild(t)&&this._compareAt(e,i)>0?i:e:i}_compareChildrenBefore(t,e,i){return this._compareAt(i,e)<=0&&i<t?i:e}_heapifyUp(t){let e=t,i=Math.floor((e-1)/2);for(;this._shouldSwap(i,e);)this._swap(i,e),e=i,i=Math.floor((e-1)/2)}_heapifyDown(t){let e=t,i=this._compareChildrenOf(e);for(;this._shouldSwap(e,i);)this._swap(e,i),e=i,i=this._compareChildrenOf(e)}_heapifyDownUntil(t){let e,i=0,s=1,r=2;for(;s<t;)e=this._compareChildrenBefore(t,s,r),this._shouldSwap(i,e)&&this._swap(i,e),i=e,s=2*i+1,r=2*i+2}insert(t){return this._nodes.push(t),this._heapifyUp(this.size()-1),(null===this._leaf||this._compare(t,this._leaf)>0)&&(this._leaf=t),this}push(t){return this.insert(t)}extractRoot(){if(this.isEmpty())return null;const t=this.root();return this._nodes[0]=this._nodes[this.size()-1],this._nodes.pop(),this._heapifyDown(0),t===this._leaf&&(this._leaf=this.root()),t}pop(){return this.extractRoot()}sort(){for(let t=this.size()-1;t>0;t-=1)this._swap(0,t),this._heapifyDownUntil(t);return this._nodes}fix(){for(let t=Math.floor(this.size()/2)-1;t>=0;t-=1)this._heapifyDown(t);for(let t=Math.floor(this.size()/2);t<this.size();t+=1){const e=this._nodes[t];(null===this._leaf||this._compare(e,this._leaf)>0)&&(this._leaf=e)}return this}isValid(){const t=e=>{let i=!0,s=!0;if(this._hasLeftChild(e)){const s=2*e+1;if(this._compareAt(e,s)>0)return!1;i=t(s)}if(this._hasRightChild(e)){const i=2*e+2;if(this._compareAt(e,i)>0)return!1;s=t(i)}return i&&s};return t(0)}clone(){return new i(this._compare,this._nodes.slice(),this._leaf)}root(){return this.isEmpty()?null:this._nodes[0]}top(){return this.root()}leaf(){return this._leaf}size(){return this._nodes.length}isEmpty(){return 0===this.size()}clear(){this._nodes=[],this._leaf=null}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:-1===t})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("Heap.heapify expects an array of values");if("function"!=typeof e)throw new Error("Heap.heapify expects a compare function");return new i(e,t).fix()}static isHeapified(t,e){return new i(e,t).isValid()}}e.Heap=i},945:(t,e,i)=>{const{Heap:s}=i(613),r=t=>(e,i)=>("function"==typeof t?t(e):e)<("function"==typeof t?t(i):i)?1:-1;class n{constructor(t,e){this._getCompareValue=t,this._heap=e||new s(r(t))}insert(t){return this._heap.insert(t)}push(t){return this.insert(t)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}toArray(){return Array.from(this._heap._nodes)}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new n(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:-1===t})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("MaxHeap.heapify expects an array");const i=new s(r(e),t);return new n(e,i).fix()}static isHeapified(t,e){const i=new s(r(e),t);return new n(e,i).isValid()}}e.MaxHeap=n},573:(t,e,i)=>{const{Heap:s}=i(613),r=t=>(e,i)=>("function"==typeof t?t(e):e)<=("function"==typeof t?t(i):i)?-1:1;class n{constructor(t,e){this._getCompareValue=t,this._heap=e||new s(r(t))}toArray(){return Array.from(this._heap._nodes)}insert(t){return this._heap.insert(t)}push(t){return this.insert(t)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new n(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:-1===t})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("MinHeap.heapify expects an array");const i=new s(r(e),t);return new n(e,i).fix()}static isHeapified(t,e){const i=new s(r(e),t);return new n(e,i).isValid()}}e.MinHeap=n},82:(t,e,i)=>{const{MinPriorityQueue:s}=i(192),{MaxPriorityQueue:r}=i(387),{PriorityQueue:n}=i(515);t.exports={MinPriorityQueue:s,MaxPriorityQueue:r,PriorityQueue:n}},387:(t,e,i)=>{const{Heap:s,MaxHeap:r}=i(436);class n{constructor(t,e){if(t&&"function"!=typeof t)throw new Error("MaxPriorityQueue constructor requires a callback for object values");this._heap=e||new r(t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if("function"!=typeof t)throw new Error("MaxPriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const s=this.pop();t(s)?e.push(s):i.push(s)}return i.forEach((t=>this.push(t))),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:-1===t})}}static fromArray(t,e){const i=new s((t=>(e,i)=>("function"==typeof t?t(e):e)<("function"==typeof t?t(i):i)?1:-1)(e),t);return new n(e,new r(e,i).fix())}}e.MaxPriorityQueue=n},192:(t,e,i)=>{const{Heap:s,MinHeap:r}=i(436);class n{constructor(t,e){if(t&&"function"!=typeof t)throw new Error("MinPriorityQueue constructor requires a callback for object values");this._heap=e||new r(t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if("function"!=typeof t)throw new Error("MinPriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const s=this.pop();t(s)?e.push(s):i.push(s)}return i.forEach((t=>this.push(t))),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:-1===t})}}static fromArray(t,e){const i=new s((t=>(e,i)=>("function"==typeof t?t(e):e)<=("function"==typeof t?t(i):i)?-1:1)(e),t);return new n(e,new r(e,i).fix())}}e.MinPriorityQueue=n},515:(t,e,i)=>{const{Heap:s}=i(436);class r{constructor(t,e){if("function"!=typeof t)throw new Error("PriorityQueue constructor expects a compare function");this._heap=new s(t,e),e&&this._heap.fix()}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if("function"!=typeof t)throw new Error("PriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const s=this.pop();t(s)?e.push(s):i.push(s)}return i.forEach((t=>this.push(t))),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:-1===t})}}static fromArray(t,e){return new r(e,t)}}e.PriorityQueue=r},629:e=>{"use strict";e.exports=t},295:t=>{"use strict";t.exports=e}},s={};function r(t){var e=s[t];if(void 0!==e)return e.exports;var n=s[t]={exports:{}};return i[t](n,n.exports,r),n.exports}r.d=(t,e)=>{for(var i in e)r.o(e,i)&&!r.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};return(()=>{"use strict";r.r(n),r.d(n,{SupalosaBot:()=>Xt,version:()=>Zt});var t=r(629);function e(t){return t.getRealMapSize()}function i(t,e,i,s){let r=0,n=0;for(let a=i.x;a<s.x;++a)for(let o=i.y;o<s.y;++o){let i=t.getTile(a,o);i&&(++r,t.isVisibleTile(i,e.name)&&++n)}return{visibleTiles:n,validTiles:r}}function s(e,i,s,r,n,a){let o=r+Math.round(e.generateRandom()*(n-r)),h=t.GameMath.atan2(s.y-i.y,s.x-i.x)-(a*(Math.PI/12)+2*a*e.generateRandom()*(Math.PI/12)),c=Math.round(i.x+t.GameMath.cos(h)*o),u=Math.round(i.y+t.GameMath.sin(h)*o);return new t.Vector2(c,u)}function a(e,i){return new t.Vector2(e.rx,e.ry).distanceTo(i)}class o{constructor(t,e,i,s){this.sectorStartPoint=t,this.sectorStartTile=e,this.sectorVisibilityPct=i,this.sectorVisibilityLastCheckTick=s,this.sectorExploreAttempts=0}onExploreAttempted(t){this.sectorExploreAttempts++,this.sectorLastExploredAt=t}shouldAttemptExploration(t,e,i){return!(i>=this.sectorExploreAttempts||this.sectorLastExploredAt&&t<this.sectorLastExploredAt+e)}}class h{constructor(e,i){this.sectors=[],this.mapBounds=i,this.sectorsX=Math.ceil(i.width/8),this.sectorsY=Math.ceil(i.height/8),this.sectors=new Array(this.sectorsX);for(let i=0;i<this.sectorsX;++i){this.sectors[i]=new Array(this.sectorsY);for(let s=0;s<this.sectorsY;++s){const r=8*i,n=8*s;this.sectors[i][s]=new o(new t.Vector2(r,n),e.getTile(r,n),void 0,void 0)}}}getMapBounds(){return this.mapBounds}updateSectors(e,s,r,n){let a=this.lastUpdatedSectorX?this.lastUpdatedSectorX+1:0,o=this.lastUpdatedSectorY?this.lastUpdatedSectorY:0,h=0;for(;h<s;){a>=this.sectorsX&&(a=0,++o),o>=this.sectorsY&&(o=0,a=0);let s=this.getSector(a,o);if(s){s.sectorVisibilityLastCheckTick=e;let a=s.sectorStartPoint,o=i(r,n,a,new t.Vector2(a.x+8,a.y+8));o.validTiles>0?s.sectorVisibilityPct=o.visibleTiles/o.validTiles:s.sectorVisibilityPct=void 0}this.lastUpdatedSectorX=a,this.lastUpdatedSectorY=o,++a,++h}}getSectorUpdateRatio(t){let e=0,i=0;for(let s=0;s<this.sectorsX;++s)for(let r=0;r<this.sectorsY;++r){let n=this.sectors[s][r];n&&n.sectorVisibilityLastCheckTick&&n.sectorVisibilityLastCheckTick>=t&&++e,++i}return e/i}getOverallVisibility(){let t=0,e=0;for(let i=0;i<this.sectorsX;++i)for(let s=0;s<this.sectorsY;++s){let r=this.sectors[i][s];null!=r.sectorVisibilityPct&&(t+=r.sectorVisibilityPct,e+=1)}return t/e}getSector(t,e){if(!(t<0||t>=this.sectorsX||e<0||e>=this.sectorsY))return this.sectors[t][e]}getSectorBounds(){return{width:this.sectorsX,height:this.sectorsY}}getSectorCoordinatesForWorldPosition(t,e){if(!(t<0||t>=this.mapBounds.width||e<0||e>=this.mapBounds.height))return{sectorX:Math.floor(t/8),sectorY:Math.floor(e/8)}}getSectorForWorldPosition(t,e){if(this.getSectorCoordinatesForWorldPosition(t,e))return this.sectors[Math.floor(t/8)][Math.floor(e/8)]}}const c=new WeakMap,u=(t,e)=>{const i=t.getGameObjectData(e);if(!i)return null;const{rulesApi:s}=t,{name:r}=i;let n=c.get(t);if(n||(n={},c.set(t,n)),n[r])return n[r];const a=s.aircraftRules.get(r);if(a)return n[r]=a,a;const o=s.buildingRules.get(r);if(o)return n[r]=o,o;const h=s.infantryRules.get(r);if(h)return n[r]=h,h;const u=s.vehicleRules.get(r);return u?(n[r]=u,u):(n[r]=null,null)};class l{constructor(t,e){this.uniqueName=t,this.logger=e,this.active=!0,this.unitIds=[],this.centerOfMass=null,this.maxDistanceToCenterOfMass=null,this.onFinish=()=>{}}updateCenterOfMass(e){const i=(e=>{if(0===e.length)return null;const i=e.reduce((({x:t,y:e},i)=>({x:t+(i?.rx||0),y:e+(i?.ry||0)})),{x:0,y:0}),s=new t.Vector2(Math.round(i.x/e.length),Math.round(i.y/e.length)),r=e.map((t=>a(t,s))),n=Math.max(...r);return{centerOfMass:s,maxDistance:n}})(this.unitIds.map((t=>e.getGameObjectData(t))).map((t=>t?.tile)).filter((t=>!!t)));i?(this.centerOfMass=i.centerOfMass,this.maxDistanceToCenterOfMass=i.maxDistance):(this.centerOfMass=null,this.maxDistanceToCenterOfMass=null)}onAiUpdate(t,e,i,s,r,n){return this.updateCenterOfMass(t),this._onAiUpdate(t,e,i,s,r,n)}isActive(){return this.active}getUnitIds(){return this.unitIds}removeUnit(t){this.unitIds=this.unitIds.filter((e=>e!=t))}addUnit(t){this.unitIds.push(t)}getUnits(t){return this.unitIds.map((e=>t.getUnitData(e))).filter((t=>null!=t)).map((t=>t))}getUnitsGameObjectData(t){return this.unitIds.map((e=>t.getGameObjectData(e))).filter((t=>null!=t)).map((t=>t))}getUnitsOfTypes(t,...e){return this.unitIds.map((e=>t.getUnitData(e))).filter((t=>!!t&&e.includes(t.name))).map((t=>t))}getUnitsMatchingByRule(t,e){return this.unitIds.map((e=>({unitId:e,rules:u(t,e)}))).filter((t=>null!==t.rules)).filter((({rules:t})=>e(t))).map((({unitId:t})=>t))}getCenterOfMass(){return this.centerOfMass}getMaxDistanceToCenterOfMass(){return this.maxDistanceToCenterOfMass}getUniqueName(){return this.uniqueName}endMission(t){this.onFinish(this.unitIds,t),this.active=!1}then(t){return this.onFinish=t,this}isUnitsLocked(){return!0}}const g=t=>({type:"disband",reason:t}),d=t=>"disband"===t.action.type,p=(t,e)=>({type:"request",unitNames:t,priority:e}),m=t=>"request"===t.action.type,y=(t,e)=>({type:"requestSpecific",unitIds:t,priority:e}),f=t=>"requestSpecific"===t.action.type,T=(t,e)=>({type:"requestCombatants",point:t,radius:e}),A=t=>"requestCombatants"===t.action.type,b=t=>({type:"releaseUnits",unitIds:t}),w=t=>"releaseUnits"===t.action.type;class x extends l{constructor(t,e,i,s){super(t,s),this.priority=e,this.selectedMcv=i,this.hasAttemptedDeployWith=null}_onAiUpdate(e,i,s,r,n,a){const o=["AMCV","SMCV"],h=this.getUnitsOfTypes(e,...o);return 0===h.length?null!==this.hasAttemptedDeployWith?g():this.selectedMcv?y([this.selectedMcv],this.priority):p(o,this.priority):((!this.hasAttemptedDeployWith||e.getCurrentTick()>this.hasAttemptedDeployWith.gameTick+30)&&(s.orderUnits(h.map((t=>t.id)),t.OrderType.DeploySelected),this.hasAttemptedDeployWith={unitId:h[0].id,gameTick:e.getCurrentTick()}),{type:"noop"})}getGlobalDebugText(){return`Expand with MCV ${this.selectedMcv}`}getPriority(){return this.priority}}class M{getName(){return"ExpansionMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){t.getVisibleUnits(e.name,"self",(e=>t.getGeneralRules().baseUnit.includes(e.name))).forEach((t=>{s.addMission(new x("expand-with-"+t,100,t,n))}))}onMissionFailed(t,e,i,s,r,n){}}var P;!function(t){t.USA="Americans",t.KOREA="Alliance",t.FRANCE="French",t.GERMANY="Germans",t.GREAT_BRITAIN="British",t.LIBYA="Africans",t.IRAQ="Arabs",t.CUBA="Confederation",t.RUSSIA="Russians"}(P||(P={}));const S=t=>"@@NEUTRAL@@"===t?.owner;function v(t,e="0000"){let i=""+t;return e.substring(0,e.length-i.length)+i}function k(t,e){if(0===t.length)return null;let i=0,s=e(t[0]);for(let r=1;r<t.length;++r){const n=e(t[r]);(null===s||null!==n&&n>s)&&(i=r,s=n)}return t[i]}function C(t,e){return t.reduce(((t,i)=>{const s=e(i);return void 0===s||(t[s]||(t[s]=0),t[s]=t[s]+1),t}),{})}function U(t,e){return t.reduce(((t,i)=>{const s=e(i);return void 0===s||(t.hasOwnProperty(s)||(t[s]=[]),t[s].push(i)),t}),{})}class D{constructor(t,e,i,s,r=0){this._unitId=t,this._orderType=e,this._point=i,this._targetId=s,this._nonce=r}static noTarget(t,e,i=0){return new D(t,e,void 0,void 0,i)}static toPoint(t,e,i,s=0){return new D(t,e,i,void 0)}static toTargetId(t,e,i,s=0){return new D(t,e,void 0,i,s)}get unitId(){return this._unitId}get orderType(){return this._orderType}get point(){return this._point}get targetId(){return this._targetId}isSameAs(t){return this._unitId===t._unitId&&this._orderType===t._orderType&&this._point===t._point&&this._targetId===t._targetId&&this._nonce===t._nonce}}class N{constructor(){this.actions=[]}push(t){this.actions.push(t)}resolve(e){const i=U(this.actions,(t=>t.orderType.valueOf().toString()));Object.entries(i).forEach((([i,s])=>{const r=parseInt(i),n=U(s.filter((t=>!!t.targetId)),(t=>t.targetId?.toString()));Object.entries(n).forEach((([t,i])=>{e.orderUnits(i.map((t=>t.unitId)),r,parseInt(t))}));const a=U(s.filter((t=>!!t.point)),(t=>{return(e=t.point).x+","+e.y;var e}));Object.entries(a).forEach((([i,s])=>{const n=(e=>{const[i,s]=e.split(",");return new t.Vector2(parseInt(i),parseInt(s))})(i);e.orderUnits(s.map((t=>t.unitId)),r,n.x,n.y)}));const o=s.filter((t=>!t.targetId&&!t.point));o.length>0&&e.orderUnits(o.map((t=>t.unitId)),r)}))}}function E(e,i){return"E1"===e.name&&e.stance===t.StanceType.Deployed?D.noTarget(e.id,t.OrderType.DeploySelected,1):D.toPoint(e.id,t.OrderType.AttackMove,i)}function _(e,i){const s=(r=e,n=i,new t.Vector2(r.tile.rx,r.tile.ry).distanceTo(new t.Vector2(n.tile.rx,n.tile.ry)));var r,n;if("E1"===e.name){const i=e.secondaryWeapon?.maxRange||5,r=e.stance===t.StanceType.Deployed;if(!r&&(s<=i||e.attackState===t.AttackState.JustFired))return D.noTarget(e.id,t.OrderType.DeploySelected,0);if(r&&s>i)return D.noTarget(e.id,t.OrderType.DeploySelected,1)}let a=i,o=t.OrderType.Attack;const h=e.primaryWeapon?.maxRange||5;return a?.type==t.ObjectType.Building&&s<.8*h?o=t.OrderType.Attack:(a?.rules.canDisguise||a?.rules.underwater)&&(o=t.OrderType.ForceAttack),D.toTargetId(e.id,o,i.id)}function R(e,i){const{rx:s,ry:r}=e.tile,{rx:n,ry:a}=i.tile;return["SUB","DLPH","SQD"].includes(e.name),["DEST","AEGIS","CARRIER","SUB","HYD","DRED","DLPH","SQD"].includes(i.name),(e.primaryWeapon?.projectileRules.isAntiAir||i.zone!==t.ZoneType.Air)&&(["CARRIER","DRED"].includes(e.name)||e.primaryWeapon?.projectileRules.isAntiGround||i.zone!==t.ZoneType.Ground)?1e6-(o=new t.Vector2(s,r),h=new t.Vector2(n,a),o.distanceTo(h)):null;var o,h}var $,V,O;!function(t){t[t.Gathering=0]="Gathering",t[t.Attacking=1]="Attacking"}($||($={}));class I{constructor(t,e,i){this.rallyArea=t,this.targetArea=e,this.radius=i,this.lastCommand=null,this.state=$.Gathering,this.lastOrderGiven={}}getGlobalDebugText(){return this.debugLastTarget??"<none>"}setAttackArea(t){this.targetArea=t}onAiUpdate(e,i,s,r,n,a,o){if(n.getUnitIds().length>0&&(!this.lastCommand||e.getCurrentTick()>this.lastCommand+10)){this.lastCommand=e.getCurrentTick();const i=n.getCenterOfMass(),h=n.getMaxDistanceToCenterOfMass(),c=n.getUnitsMatchingByRule(e,(t=>t.isSelectableCombatant)).map((t=>e.getUnitData(t))).filter((t=>!!t)),u=n.getUnitsMatchingByRule(e,(e=>e.isSelectableCombatant&&(e.movementZone===t.MovementZone.Infantry||e.movementZone===t.MovementZone.Normal||e.movementZone===t.MovementZone.InfantryDestroyer)));if(this.state===$.Gathering){const r=10*t.GameMath.sqrt(u.length)+5;i&&h&&void 0!==e.mapApi.getTile(i.x,i.y)&&h>r?c.forEach((t=>{this.submitActionIfNew(s,E(t,i))})):(o(`CombatSquad ${n.getUniqueName()} switching back to attack mode (${h})`),this.state=$.Attacking)}else{const l=this.targetArea||r.startLocation,g=10*t.GameMath.sqrt(u.length)+15;if(i&&h&&void 0!==e.mapApi.getTile(i.x,i.y)&&h>g)return o(`CombatSquad ${n.getUniqueName()} switching back to gather (${h})`),this.state=$.Gathering,{type:"noop"};const d=t=>t.primaryWeapon?.maxRange??t.secondaryWeapon?.maxRange??5,p=function(t,e){if(0===t.length)return null;let i=0,s=e(t[0]);for(let r=1;r<t.length;++r){const n=e(t[r]);(null===s||null!==n&&n<s)&&(i=r,s=n)}return t[i]}(c,d),m=k(c,d),y=Math.max(15,m?d(m):15);if(!p)return{type:"noop"};const f=a.getHostilesNearPoint2d(this.targetArea,2*y).map((({unitId:t})=>e.getUnitData(t))).filter((t=>!!t&&!S(t)));for(const e of c){const r=["FV","HTK"].includes(e.name),n=["SUB","DLPH","SQD"].includes(e.name),a=d(e),h=Math.max(15,a),c=f.filter((i=>t.GameMath.sqrt(t.GameMath.pow(i.tile.rx-e.tile.rx,2)+t.GameMath.pow(i.tile.ry-e.tile.ry,2))<=h));if(r){const r=k(c.filter((e=>e.zone===t.ZoneType.Air)),(t=>R(e,t)));r?(this.submitActionIfNew(s,_(e,r)),this.debugLastTarget=`AA ${r.id.toString()}`):i?(this.submitActionIfNew(s,E(e,i)),this.debugLastTarget=`escort@${i.x},${i.y}`):(this.submitActionIfNew(s,E(e,l)),this.debugLastTarget=`escort->@${l.x},${l.y}`);continue}n&&(o(`[NAVAL_DEBUG] Underwater unit ${e.name}(id:${e.id}) starting to find attack target (scan=${h})`),o(`[NAVAL_DEBUG]   Found ${c.length} hostile targets within scan range`),c.forEach(((t,i)=>{const s=R(e,t),r=["DEST","AEGIS","CARRIER","SUB","HYD","DRED","DLPH","SQD"].includes(t.name);o(`[NAVAL_DEBUG]     Target ${i+1}: ${t.name}(id:${t.id}) weight=${s} is naval=${r}`)})));const u=k(c,(t=>R(e,t)));u?(n&&o(`[NAVAL_DEBUG]   Choosing attack target: ${u.name}(id:${u.id})`),this.submitActionIfNew(s,_(e,u)),this.debugLastTarget=`Unit ${u.id.toString()}`):(n&&o("[NAVAL_DEBUG]   No suitable attack target found, moving to target point"),this.submitActionIfNew(s,E(e,l)),this.debugLastTarget=`@${l.x},${l.y}`)}}}return{type:"noop"}}submitActionIfNew(t,e){const i=this.lastOrderGiven[e.unitId];i&&i.isSameAs(e)||(t.push(e),this.lastOrderGiven[e.unitId]=e)}}class L extends l{constructor(t,e,i,s){super(t,s),this.retreatToPoint=e,this.withUnitIds=i,this.createdAt=null}_onAiUpdate(e,i,s,r,n,a){return this.createdAt||(this.createdAt=e.getCurrentTick()),this.getUnitIds().length>0?(s.orderUnits(this.getUnitIds(),t.OrderType.AttackMove,this.retreatToPoint.x,this.retreatToPoint.y),g()):this.createdAt&&e.getCurrentTick()>this.createdAt+240?g():y(this.withUnitIds,1e3)}getGlobalDebugText(){return`retreat with ${this.withUnitIds.length} units`}getPriority(){return 100}}function G(e){return function(i){const s=[t.QueueType.Structures,t.QueueType.Armory,t.QueueType.Infantry,t.QueueType.Vehicles,t.QueueType.Aircrafts,t.QueueType.Ships];for(const t of s)try{if(e.getAvailableObjects(t).some((t=>t.name===i)))return!0}catch(t){continue}return!1}}function q(e,i,s,r,n=1,a=!1){const o=e.mapApi.getTile(i.x,i.y),h=e.mapApi.getTile(s.x,s.y);if(!o||!h)return!1;const c=void 0!==o.onBridgeLandType,u=void 0!==h.onBridgeLandType,l=e.mapApi.findPath(r,a,{tile:o,onBridge:c},{tile:h,onBridge:u});if(!l||0===l.length)return!1;const g=l[0].tile;return new t.Vector2(g.rx,g.ry).distanceTo(s)<=n}function B(e,i,s,r,n=!1){if(!i.country)throw new Error(`player ${i.name} has no country`);return n?i.country.side===t.SideType.Nod?((t,e,i,s)=>(t.getVisibleUnits(e.name,"self",(t=>"NAYARD"===t.name)).length,t.getVisibleUnits(e.name,"self",(t=>"NARADR"===t.name)).length,t.getVisibleUnits(e.name,"self",(t=>"NATECH"===t.name)).length,{DRED:1}))(e,i):((t,e,i,s)=>{t.getVisibleUnits(e.name,"self",(t=>"GAYARD"===t.name)).length;const r=t.getVisibleUnits(e.name,"self",(t=>"GAAIRC"===t.name||"AMRADR"===t.name)).length>0,n=t.getVisibleUnits(e.name,"self",(t=>"GATECH"===t.name)).length>0;let a={DEST:3};return r&&(a.AEGIS=1),n&&(a.CARRIER=1,a.DLPH=2),a})(e,i):i.country.side===t.SideType.Nod?((t,e,i,s)=>{const r=G(s),n=r("E2"),a=r("DESO"),o=r("HTNK"),h=r("HTK"),c=r("V3"),u=r("TTNK"),l=r("APOC"),g=r("SHK"),d=!l&&n,p={};return a&&(p.DESO=1),g&&(p.SHK=1),p.E2=d?10:1,o&&(p.HTNK=5),c&&(p.V3=1),h&&(o||c)&&(p.HTK=1),u&&(p.TTNK=1),l&&(p.APOC=2),p})(0,0,0,r):((t,e,i,s)=>{const r=G(s),n=r("E1"),a=r("SNIPE"),o=r("JUMPJET"),h=r("TNKD"),c=r("MTNK"),u=r("FV"),l=r("SREF"),g=r("MGTK"),d={};return!o&&!l&&n&&(d.E1=5),a&&(d.SNIPE=1),c&&!o&&(d.MTNK=6,u&&(d.FV=1)),c&&o&&(d.MTNK=3),h&&(d.TNKD=1),o&&(d.JUMPJET=6,u&&(d.FV=1)),l&&(d.SREF=2,g&&(d.MGTK=3),u&&(d.FV=1)),d})(0,0,0,r)}function F(e,i,s){if(!i.country)throw new Error(`player ${i.name} has no country`);return i.country.side===t.SideType.Nod?((t,e,i)=>{const s={};return t.getVisibleUnits(e.name,"self",(t=>"NAWEAP"===t.name)).length>0&&(s.HTK=2),s})(e,i):((t,e,i)=>{const s={};return t.getVisibleUnits(e.name,"self",(t=>"GAWEAP"===t.name)).length>0&&(s.FV=2),s})(e,i)}!function(t){t[t.NoTargets=0]="NoTargets",t[t.DefenceTooStrong=1]="DefenceTooStrong"}(V||(V={})),function(t){t[t.Preparing=0]="Preparing",t[t.Attacking=1]="Attacking",t[t.Retreating=2]="Retreating"}(O||(O={}));class j extends l{constructor(t,e,i,s,r,n,a,o){super(t,a),this.priority=e,this.rallyArea=i,this.attackArea=s,this.radius=r,this.composition=n,this.eventBus=o,this.hasTriedLandAttack=!1,this.landAttackFailCount=0,this.MAX_LAND_ATTACK_ATTEMPTS=2,this.isNavalMission=!1,this.navalModeStartTick=0,this.navalYardRequestAttempts=0,this.unsubscribeFromEvents=null,this.MAX_NAVAL_YARD_ATTEMPTS=2,this.NAVAL_YARD_WAIT_TICKS=4500,this.lastTargetSeenAt=0,this.hasPickedNewTarget=!1,this.state=O.Preparing,this.squad=new I(i,s,r)}shouldSwitchToNaval(e,i){if(this.logger(`shouldSwitchToNaval? tick=${e.getCurrentTick()} | isNavalMission=${this.isNavalMission} | landFails=${this.landAttackFailCount}/${this.MAX_LAND_ATTACK_ATTEMPTS}`),this.logger(`    rallyArea=(${this.rallyArea.x},${this.rallyArea.y}) attackArea=(${this.attackArea.x},${this.attackArea.y})`),this.isNavalMission)return this.logger("    Already naval mission, skip switch check."),!1;const s=q(e,this.rallyArea,this.attackArea,t.SpeedType.Track,6);if(this.logger(`    pathReachable=${s}`),!s){const s=e.mapApi.getTile(this.rallyArea.x,this.rallyArea.y),r=e.mapApi.getTile(this.attackArea.x,this.attackArea.y),n=(q(e,this.rallyArea,this.attackArea,t.SpeedType.Track,6),e.getVisibleUnits(i.name,"enemy").map((t=>e.getUnitData(t))).filter((t=>void 0!==t)).filter((e=>new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(this.attackArea)<=3)));return this.logger(`Attack Area (${this.attackArea.x},${this.attackArea.y}) radius ${this.radius} found ${n.length} enemy units:`),n.forEach(((e,i)=>{const s=new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(this.attackArea);this.logger(`  ${i+1}. ${e.name}(id:${e.id}) distance:${s.toFixed(1)} type:${e.type} health:${e.hitPoints}/${e.maxHitPoints}`)})),this.logger(`Target point unreachable for land units, switching to naval formation | rallyTile type: ${s?.landType??"unknown"} | attackTile type: ${r?.landType??"unknown"}`),!0}return this.landAttackFailCount>=this.MAX_LAND_ATTACK_ATTEMPTS&&(this.logger("Too many land attack failures, switching to naval formation"),!0)}_onAiUpdate(t,e,i,s,r,n){switch(this.state){case O.Preparing:return this.handlePreparingState(t,e,i,s,r,n);case O.Attacking:return this.handleAttackingState(t,i,s,r,n);case O.Retreating:return this.handleRetreatingState(t,i,s,r,n)}}handlePreparingState(e,i,s,r,n,a){if(!this.isNavalMission&&this.shouldSwitchToNaval(e,r))return this.isNavalMission=!0,this.eventBus.publish({type:"modeChanged",player:r.name,isNaval:!0}),this.unsubscribeFromEvents||(this.unsubscribeFromEvents=this.eventBus.subscribe((t=>{"yardFailed"===t.type&&t.player===r.name&&this.navalYardRequestAttempts++}))),this.navalModeStartTick=e.getCurrentTick(),this.navalYardRequestAttempts=0,this.composition=B(e,r,0,i,!0),this.logger("Switched to naval formation"),this.logger(`[NAVAL_DEBUG] Naval formation composition: ${JSON.stringify(this.composition)}`),{type:"noop"};const o=C(this.getUnitsGameObjectData(e),(t=>t.name)),h=F(e,r),c=Object.fromEntries(Object.keys(h).map((t=>[t,o[t]||0])));if(this.isNavalMission&&q(e,this.rallyArea,this.attackArea,t.SpeedType.Track,6))return this.logger("[NAVAL_DEBUG] Land path is now clear, switching back to land mode"),this.unsubscribeFromEvents&&(this.unsubscribeFromEvents(),this.unsubscribeFromEvents=null),this.isNavalMission=!1,this.eventBus.publish({type:"modeChanged",player:r.name,isNaval:!1}),this.priority=Q,this.composition=B(e,r,0,i,!1),{type:"noop"};const u=e.getVisibleUnits(r.name,"self",(t=>"GAYARD"===t.name||"NAYARD"===t.name)).length>0;if(this.isNavalMission&&!u){if(e.getCurrentTick()-this.navalModeStartTick>this.NAVAL_YARD_WAIT_TICKS||this.navalYardRequestAttempts>=this.MAX_NAVAL_YARD_ATTEMPTS)return this.logger(`[NAVAL_DEBUG] Naval yard unable to build for long time, falling back to land mode, attempts: ${this.navalYardRequestAttempts}, wait time: ${e.getCurrentTick()-this.navalModeStartTick}`),this.unsubscribeFromEvents&&(this.unsubscribeFromEvents(),this.unsubscribeFromEvents=null),this.isNavalMission=!1,this.eventBus.publish({type:"modeChanged",player:r.name,isNaval:!1}),this.composition=B(e,r,0,i,!1),{type:"noop"};if(this.navalYardRequestAttempts<this.MAX_NAVAL_YARD_ATTEMPTS){const e=r.country?.side===t.SideType.Nod?"NAYARD":"GAYARD";return p([e],100*this.priority)}}this.isNavalMission&&(this.logger(`[NAVAL_DEBUG] Current naval unit composition: ${JSON.stringify(o)}`),this.logger(`[NAVAL_DEBUG] Target naval formation composition: ${JSON.stringify(this.composition)}`));const l=Object.entries(this.composition).filter((([t,e])=>!o[t]||o[t]<e));if(l.length>0){this.isNavalMission&&this.logger(`[NAVAL_DEBUG] Missing naval units: ${JSON.stringify(l)}`),this.priority=Math.min(1.01*this.priority,50);const t=l.map((([t])=>t));return this.logger(`Requesting units: ${JSON.stringify(t)}`),t.includes("HTK")&&this.logger("[DEBUG] Requesting HTK"),p(t,this.priority)}if(this.isNavalMission)this.logger("[NAVAL_DEBUG] Naval formation ready, starting attack phase"),this.priority=Q,this.state=O.Attacking;else{const t=Object.entries(h).filter((([t,e])=>(c[t]||0)<e)),e=this.priority;if(this.priority=Q,this.state=O.Attacking,t.length>0)return p(t.map((([t])=>t)),e)}return{type:"noop"}}handleAttackingState(t,e,i,s,r){if(0===this.getUnitIds().length)return!this.isNavalMission&&(this.landAttackFailCount++,this.shouldSwitchToNaval(t,i))?(this.state=O.Preparing,{type:"noop"}):(this.state=O.Retreating,{type:"noop"});const n=s.getHostilesNearPoint2d(this.attackArea,this.radius).map((e=>t.getUnitData(e.unitId))).filter((t=>!S(t))),a=this.squad.onAiUpdate(t,e,r,i,this,s,this.logger);if("noop"!==a.type)return a;if(n.length>0)this.lastTargetSeenAt=t.getCurrentTick(),this.hasPickedNewTarget=!1;else{if(t.getCurrentTick()>this.lastTargetSeenAt+900)return g(V.NoTargets);if(!this.hasPickedNewTarget&&t.getCurrentTick()>this.lastTargetSeenAt+450){const e=H(t,i,s,!1,this.logger);e&&(this.squad.setAttackArea(e),this.hasPickedNewTarget=!0)}}if(!this.isNavalMission){const e=F(t,i);if(Object.keys(e).length>0){const i=C(this.getUnitsGameObjectData(t),(t=>t.name)),s=Object.fromEntries(Object.keys(e).map((t=>[t,i[t]||0]))),r=Object.entries(e).filter((([t,e])=>(s[t]||0)<e));if(r.length>0)return this.priority=Math.min(1.01*this.priority,50),p(r.map((([t])=>t)),this.priority)}}return{type:"noop"}}handleRetreatingState(t,e,i,s,r){return this.getUnits(t).forEach((t=>{r.push(E(t,s.getMainRallyPoint()))})),g()}getGlobalDebugText(){return this.squad.getGlobalDebugText()??"<none>"}getState(){return this.state}isUnitsLocked(){return this.state!==O.Preparing}getPriority(){return this.priority}isNaval(){return this.isNavalMission}}function H(e,i,s,r=!1,n){const a=s.getMainRallyPoint();try{const s=0===e.generateRandomInt(0,1),o=e.getVisibleUnits(i.name,"enemy").map((t=>e.getUnitData(t))).filter((t=>!!t&&e.getPlayerData(t.owner).isCombatant)),h=i=>{let r=((e,i)=>i&&e.rules.harvester?1e5:e.type===t.ObjectType.Building?10*e.maxHitPoints:e.maxHitPoints)(i,s);try{q(e,a,new t.Vector2(i.tile.rx,i.tile.ry),t.SpeedType.Track,6)||(r*=.3)}catch(t){r*=.3}return r},c=k(o,h);if(c)return n?.(`generateTarget: picked visible enemy unit ${c.name} (id=${c.id}) at (${c.tile.rx},${c.tile.ry})`),new t.Vector2(c.tile.rx,c.tile.ry);if(r){const t=e.mapApi,s=e.getPlayers().map((t=>e.getPlayerData(t))).filter((t=>!e.areAlliedPlayers(i.name,t.name))).filter((e=>{const s=t.getTile(e.startLocation.x,e.startLocation.y);return!!s&&!t.isVisibleTile(s,i.name)}));if(s.length>0){const t=s[e.generateRandomInt(0,s.length-1)].startLocation;return n?.(`generateTarget: picked unexplored enemy base at (${t.x},${t.y})`),t}}}catch(t){n?.(`generateTarget: ERROR while selecting target: ${t}`)}try{const s=e.getGeneralRules().baseUnit??[],r=e.getVisibleUnits(i.name,"enemy",(t=>!!t.deploysInto&&s.includes(t.name)));if(r.length>0){const i=r[0],s=e.getUnitData(i);if(s)return n?.(`generateTarget: fallback to enemy MCV ${s.name} (id=${s.id}) at (${s.tile.rx},${s.tile.ry})`),new t.Vector2(s.tile.rx,s.tile.ry)}}catch(t){}return null}const Q=1;class W{constructor(t){this.eventBus=t,this.lastAttackAt=-120}getName(){return"AttackMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){if(t.getCurrentTick()<this.lastAttackAt+120)return;if(s.getMissions().some((t=>t instanceof j&&t.getState()===O.Preparing)))return;const a=t.getCurrentTick()>this.lastAttackAt+1800,o=H(t,e,i,a,n);if(!o)return;const h="attack_"+t.getCurrentTick(),c=B(t,e,0,r);s.addMission(new j(h,Q,i.getMainRallyPoint(),o,10,c,n,this.eventBus).then(((e,r)=>{s.addMission(new L("retreat-from-"+h+t.getCurrentTick(),i.getMainRallyPoint(),e,n))})))&&(this.lastAttackAt=t.getCurrentTick())}onMissionFailed(t,e,i,s,r,n){}}class Y extends l{constructor(t,e,i){super(t,i),this.priority=e,this.scoutTarget=null,this.attemptsOnCurrentTarget=0,this.scoutTargetRefreshedAt=0,this.lastMoveCommandTick=0,this.scoutTargetIsPermanent=!1,this.hadUnit=!1}_onAiUpdate(e,i,s,r,n,o){const h=["ADOG","DOG","E1","E2"],c=this.getUnitsOfTypes(e,...h);if((n.getSectorCache().getOverallVisibility()||0)>.9)return g();if(0===c.length)return this.scoutTarget&&this.hadUnit&&(this.attemptsOnCurrentTarget++,this.hadUnit=!1),p(h,this.priority);if(this.scoutTarget){if(this.hadUnit=!0,!this.scoutTargetIsPermanent){if(this.attemptsOnCurrentTarget>3)return this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} took too many attempts, moving to next`),this.setScoutTarget(null,0),{type:"noop"};let i=!0;if(c.length>0&&q(e,new t.Vector2(c[0].tile.rx,c[0].tile.ry),this.scoutTarget,t.SpeedType.Track,5,!1)&&(i=!1,this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} is reachable, skipping time limit`)),i&&e.getCurrentTick()>this.scoutTargetRefreshedAt+600)return this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} took too long, moving to next`),this.setScoutTarget(null,0),{type:"noop"}}const i=e.mapApi.getTile(this.scoutTarget.x,this.scoutTarget.y);if(!i)throw new Error(`target tile ${this.scoutTarget.x},${this.scoutTarget.y} does not exist`);if(e.getCurrentTick()>this.lastMoveCommandTick+30){this.lastMoveCommandTick=e.getCurrentTick(),c.forEach((e=>{this.scoutTarget&&s.orderUnits([e.id],t.OrderType.AttackMove,this.scoutTarget.x,this.scoutTarget.y)}));const i=c.map((t=>a(t.tile,this.scoutTarget))),r=Math.min(...i);(!this.scoutMinDistance||r<this.scoutMinDistance)&&(this.logger(`Scout timeout refreshed because unit moved closer to point (${r} < ${this.scoutMinDistance})`),this.scoutTargetRefreshedAt=e.getCurrentTick(),this.scoutMinDistance=r)}e.mapApi.isVisibleTile(i,r.name)&&(this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} successfully scouted, moving to next`),this.setScoutTarget(null,e.getCurrentTick()))}else{const t=n.getScoutingManager().getNewScoutTarget();if(!t)return this.logger("No more scouting targets available, disbanding."),g();this.setScoutTarget(t,e.getCurrentTick())}return{type:"noop"}}setScoutTarget(t,e){this.attemptsOnCurrentTarget=0,this.scoutTargetRefreshedAt=e,this.scoutTarget=t?.asVector2()??null,this.scoutMinDistance=void 0,this.scoutTargetIsPermanent=t?.isPermanent??!1}getGlobalDebugText(){return"scouting"}getPriority(){return this.priority}}class z{constructor(t=-300){this.lastScoutAt=t}getName(){return"ScoutingMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){t.getCurrentTick()<this.lastScoutAt+300||i.getScoutingManager().hasScoutTargets()&&(s.addMission(new Y("globalScout",10,n))||(this.lastScoutAt=t.getCurrentTick()))}onMissionFailed(t,e,i,s,r,n,a){t.getCurrentTick()<this.lastScoutAt+300||i.getScoutingManager().hasScoutTargets()&&s instanceof j&&(n.addMission(new Y("globalScout",10,a)),this.lastScoutAt=t.getCurrentTick())}}class K extends l{constructor(t,e,i,s,r,n){super(t,n),this.priority=e,this.defenceArea=s,this.radius=r,this.idleTicks=0,this.IDLE_DISBAND_THRESHOLD=90,this.squad=new I(i,s,r)}_onAiUpdate(e,i,s,r,n,a){const o=n.getHostilesNearPoint2d(this.defenceArea,this.radius).map((t=>e.getUnitData(t.unitId))).filter((t=>!S(t))),h=this.squad.onAiUpdate(e,s,a,r,this,n,this.logger);if("noop"!==h.type)return h;if(0===o.length)return this.priority=0,this.idleTicks++,this.idleTicks>=this.IDLE_DISBAND_THRESHOLD&&0===this.getUnitIds().length?(this.logger(`(Defence Mission ${this.getUniqueName()}): No threats for ${this.idleTicks} ticks and no units, disbanding.`),g()):this.getUnitIds().length>0?(this.logger(`(Defence Mission ${this.getUniqueName()}): No targets found, releasing units.`),b(this.getUnitIds())):{type:"noop"};{this.idleTicks=0;const e=o[0];return this.logger(`(Defence Mission ${this.getUniqueName()}): Focused on target ${e?.name} (${o.length} found in area ${this.radius})`),this.squad.setAttackArea(new t.Vector2(o[0].tile.rx,o[0].tile.ry)),this.priority=100,T(r.startLocation,this.priority)}}getGlobalDebugText(){return this.squad.getGlobalDebugText()??"<none>"}getPriority(){return this.priority}}class X{constructor(){this.lastDefenceCheckAt=0}getName(){return"DefenceMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){if(t.getCurrentTick()<this.lastDefenceCheckAt+30)return;this.lastDefenceCheckAt=t.getCurrentTick();const a=10+.001*t.getCurrentTick(),o=i.getHostilesNearPoint2d(e.startLocation,a).map((e=>t.getUnitData(e.unitId))).filter((t=>!S(t)));o.length>0&&(s.getMissions().filter((t=>!1===t.isUnitsLocked()&&!(t instanceof j&&t.isNaval()))).forEach((t=>{n(`Disbanding preparing mission ${t.getUniqueName()} due to defence activation.`),s.disbandMission(t.getUniqueName())})),n(`Starting defence mission, ${o.length} found in radius ${a} (tick ${t.getCurrentTick()})`),s.addMission(new K("globalDefence",10,i.getMainRallyPoint(),e.startLocation,1.2*a,n)))}onMissionFailed(t,e,i,s,r,n){}}class Z extends l{constructor(t,e,i,s){super(t,s),this.priority=e,this.captureTargetId=i,this.hasAttemptedCaptureWith=null}_onAiUpdate(e,i,s,r,n,a){const o=["ENGINEER","SENGINEER"],h=this.getUnitsOfTypes(e,...o);return 0===h.length?null!==this.hasAttemptedCaptureWith?g():p(o,this.priority):((!this.hasAttemptedCaptureWith||e.getCurrentTick()>this.hasAttemptedCaptureWith.gameTick+120)&&(s.orderUnits(h.map((t=>t.id)),t.OrderType.Capture,this.captureTargetId),this.hasAttemptedCaptureWith={unitId:h[0].id,gameTick:e.getCurrentTick()}),{type:"noop"})}getGlobalDebugText(){}getPriority(){return this.priority}}class J{constructor(){this.lastCheckAt=0}getName(){return"EngineerMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){t.getCurrentTick()>this.lastCheckAt+300&&(this.lastCheckAt=t.getCurrentTick(),t.getVisibleUnits(e.name,"hostile",(t=>t.capturable&&t.produceCashAmount>0)).forEach((t=>{s.addMission(new Z("capture-"+t,100,t,n))})))}onMissionFailed(t,e,i,s,r,n){}}function tt(i,s=8){const r=[],n=e(i.mapApi);for(let e=0;e<n.width;e+=s)for(let a=0;a<n.height;a+=s)if(e>=0&&e<n.width&&a>=0&&a<n.height){const s=i.mapApi.getTile(e,a);s&&s.landType===t.LandType.Water&&i.mapApi.findPath(t.SpeedType.Float,!0,{tile:s,onBridge:!1},{tile:s,onBridge:!1})&&r.push(new t.Vector2(e,a))}return 0===r.length&&s>2?tt(i,Math.floor(s/2)):r}function et(e,i,s){const r=e.mapApi.getTile(i.x,i.y),n=e.mapApi.getTile(s.x,s.y);if(!r||!n)return null;const a=e.mapApi.findPath(t.SpeedType.Float,!0,{tile:r,onBridge:!1},{tile:n,onBridge:!1});if(!a||0===a.length)return null;const o=a[a.length-1];return new t.Vector2(o.tile.rx,o.tile.ry)}class it extends l{constructor(t,e,i){super(t,i),this.priority=e,this.scoutTarget=null,this.attemptsOnCurrentTarget=0,this.scoutTargetRefreshedAt=0,this.lastMoveCommandTick=0,this.scoutTargetIsPermanent=!1,this.hadUnit=!1,this.waterPoints=null,this.visitedWaterPoints=new Set,this.lastPosition=null,this.lastPositionCheckTick=0}initializeWaterPoints(t){null===this.waterPoints&&(this.waterPoints=tt(t),this.logger(`Found ${this.waterPoints.length} water exploration points`))}getNextWaterTarget(t,e,i){if(this.initializeWaterPoints(t),!this.waterPoints||0===this.waterPoints.length)return null;let s=null,r=Number.MAX_VALUE;const n=i.getSectorCache(),a=new Set;this.waterPoints.forEach((t=>{const e=n.getSectorForWorldPosition(t.x,t.y);e&&void 0!==e.sectorVisibilityPct&&e.sectorVisibilityPct>0&&a.add(`${t.x},${t.y}`)})),this.visitedWaterPoints.size>=this.waterPoints.length&&(this.visitedWaterPoints=a);for(let i=0;i<this.waterPoints.length;i++){const n=this.waterPoints[i],o=`${n.x},${n.y}`;if(this.visitedWaterPoints.has(o))continue;if(a.has(o)){this.visitedWaterPoints.add(o);continue}const h=e.distanceTo(n);h<r&&et(t,e,n)&&(s=n,r=h)}if(s){const t=`${s.x},${s.y}`;this.visitedWaterPoints.add(t),this.logger(`Selected new water exploration point ${s.x},${s.y}`)}else this.visitedWaterPoints.size<this.waterPoints.length&&this.logger("Re-explore undiscovered areas");return s}isUnitStuck(t){if(!this.lastPosition)return!1;const e=Math.abs(t.x-this.lastPosition.x),i=Math.abs(t.y-this.lastPosition.y);return e<=2&&i<=2}_onAiUpdate(e,i,s,r,n,a){const o=["DLPH","DEST","SUB","HYD","SQD"],h=this.getUnitsOfTypes(e,...o);if((n.getSectorCache().getOverallVisibility()||0)>.9)return g();if(0===h.length)return this.scoutTarget&&this.hadUnit&&(this.attemptsOnCurrentTarget++,this.hadUnit=!1),p(o,this.priority);const c=h[0],u=new t.Vector2(c.tile.rx,c.tile.ry);if(e.getCurrentTick()>=this.lastPositionCheckTick+60&&(this.lastPosition&&this.isUnitStuck(u)&&(this.logger(`Unit stopped moving at ${u.x},${u.y}, searching for new target`),this.setScoutTarget(null,e.getCurrentTick())),this.lastPosition=u,this.lastPositionCheckTick=e.getCurrentTick()),this.scoutTarget){if(this.hadUnit=!0,!this.scoutTargetIsPermanent){if(this.attemptsOnCurrentTarget>5)return this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} attempted too many times, switching to next target`),this.setScoutTarget(null,0),{type:"noop"};if(e.getCurrentTick()>this.scoutTargetRefreshedAt+600)return this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} taking too long, switching to next target`),this.setScoutTarget(null,0),{type:"noop"}}const i=e.mapApi.getTile(this.scoutTarget.x,this.scoutTarget.y);if(!i)throw new Error(`Target position ${this.scoutTarget.x},${this.scoutTarget.y} does not exist`);if(e.getCurrentTick()>this.lastMoveCommandTick+30&&(this.lastMoveCommandTick=e.getCurrentTick(),h.forEach((e=>{this.scoutTarget&&s.orderUnits([e.id],t.OrderType.Move,this.scoutTarget.x,this.scoutTarget.y)}))),e.mapApi.isVisibleTile(i,r.name)){const t=`${this.scoutTarget.x},${this.scoutTarget.y}`;this.visitedWaterPoints.add(t),this.logger(`Target ${this.scoutTarget.x},${this.scoutTarget.y} scouted successfully, switching to next target`),this.setScoutTarget(null,e.getCurrentTick())}}else{const t=n.getScoutingManager().getNewScoutTarget();if(t){const i=t.asVector2();if(i){const t=et(e,u,i);if(t)return this.setScoutTarget(t,e.getCurrentTick()),this.logger(`Heading to scout target ${t.x},${t.y}`),{type:"noop"}}}const i=this.getNextWaterTarget(e,u,n);if(!i)return this.logger("No reachable water exploration points found, mission ends"),g();this.setScoutTarget(i,e.getCurrentTick())}return{type:"noop"}}setScoutTarget(t,e){this.attemptsOnCurrentTarget=0,this.scoutTargetRefreshedAt=e,this.scoutTarget=t,this.scoutTargetIsPermanent=!1,this.lastPosition=null,this.lastPositionCheckTick=e}getGlobalDebugText(){return"Naval scouting in progress"}getPriority(){return this.priority}}class st{constructor(t=-300,e){this.lastScoutAt=t,this.eventBus=e,this.navalMode=!1,this.eventBus&&this.eventBus.subscribe((t=>{"modeChanged"===t.type&&(this.navalMode=t.isNaval)}))}getName(){return"NavalScoutingMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){this.navalMode&&(t.getCurrentTick()<this.lastScoutAt+300||i.getScoutingManager().hasScoutTargets()&&(s.addMission(new it("navalScout",10,n))||(this.lastScoutAt=t.getCurrentTick())))}onMissionFailed(t,e,i,s,r,n,a){this.navalMode&&(t.getCurrentTick()<this.lastScoutAt+300||i.getScoutingManager().hasScoutTargets()&&s instanceof it&&(n.addMission(new it("navalScout",10,a)),this.lastScoutAt=t.getCurrentTick()))}}function rt(i,s=8){const r=[],n=e(i.mapApi);for(let e=0;e<n.width;e+=s)for(let a=0;a<n.height;a+=s)if(e>=0&&e<n.width&&a>=0&&a<n.height){const s=i.mapApi.getTile(e,a);s&&i.mapApi.isPassableTile(s,t.SpeedType.Amphibious,!1,!1)&&r.push(new t.Vector2(e,a))}return 0===r.length&&s>2?rt(i,Math.floor(s/2)):r}class nt extends l{constructor(t,e,i){super(t,i),this.priority=e,this.scoutTarget=null,this.attemptsOnCurrentTarget=0,this.scoutTargetRefreshedAt=0,this.lastMoveCommandTick=0,this.scoutTargetIsPermanent=!1,this.hadUnit=!1,this.amphibiousPoints=null,this.visitedPoints=new Set,this.lastPosition=null,this.lastPositionCheckTick=0}initializeAmphibiousPoints(t){if(null===this.amphibiousPoints){this.amphibiousPoints=rt(t);for(let e=this.amphibiousPoints.length-1;e>0;e--){const i=Math.floor(t.generateRandomInt(0,e));[this.amphibiousPoints[e],this.amphibiousPoints[i]]=[this.amphibiousPoints[i],this.amphibiousPoints[e]]}this.logger(`Found ${this.amphibiousPoints.length} amphibious exploration points`)}}isUnitStuck(t){if(!this.lastPosition)return!1;const e=Math.abs(t.x-this.lastPosition.x),i=Math.abs(t.y-this.lastPosition.y);return e<=2&&i<=2}getNextAmphibiousTarget(t,e,i){if(this.initializeAmphibiousPoints(t),!this.amphibiousPoints||0===this.amphibiousPoints.length)return null;let s=null,r=1/0;for(const n of this.amphibiousPoints){const o=`${n.x},${n.y}`;if(this.visitedPoints.has(o))continue;const h=t.mapApi.getTile(n.x,n.y);if(!h||t.mapApi.isVisibleTile(h,i.name)){this.visitedPoints.add(o);continue}const c=a(h,e);c<r&&(r=c,s=n)}return s}_onAiUpdate(e,i,s,r,n,o){const h=["SAPC","LCRF"],c=this.getUnitsOfTypes(e,...h);if((n.getSectorCache().getOverallVisibility()||0)>.9)return g();if(0===c.length)return this.scoutTarget&&this.hadUnit&&(this.attemptsOnCurrentTarget++,this.hadUnit=!1),p(h,this.priority);const u=c[0],l=new t.Vector2(u.tile.rx,u.tile.ry);if(e.getCurrentTick()>=this.lastPositionCheckTick+60&&(this.lastPosition&&this.isUnitStuck(l)&&(this.logger(`Unit stuck at ${l.x},${l.y}, looking for new target`),this.setScoutTarget(null,e.getCurrentTick())),this.lastPosition=l,this.lastPositionCheckTick=e.getCurrentTick()),this.scoutTarget){if(this.hadUnit=!0,!this.scoutTargetIsPermanent){if(this.attemptsOnCurrentTarget>5)return this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} exceeded max attempts, switching to next target`),this.setScoutTarget(null,0),{type:"noop"};if(e.getCurrentTick()>this.scoutTargetRefreshedAt+600)return this.logger(`Scout target ${this.scoutTarget.x},${this.scoutTarget.y} taking too long, switching to next target`),this.setScoutTarget(null,0),{type:"noop"}}const i=e.mapApi.getTile(this.scoutTarget.x,this.scoutTarget.y);if(!i)throw new Error(`Target position ${this.scoutTarget.x},${this.scoutTarget.y} does not exist`);if(e.getCurrentTick()>this.lastMoveCommandTick+30){this.lastMoveCommandTick=e.getCurrentTick(),c.forEach((e=>{this.scoutTarget&&s.orderUnits([e.id],t.OrderType.AttackMove,this.scoutTarget.x,this.scoutTarget.y)}));const i=c.map((t=>a(t.tile,this.scoutTarget))),r=Math.min(...i);(!this.scoutMinDistance||r<this.scoutMinDistance)&&(this.logger(`Unit approaching target point (${r} < ${this.scoutMinDistance})`),this.scoutTargetRefreshedAt=e.getCurrentTick(),this.scoutMinDistance=r)}if(e.mapApi.isVisibleTile(i,r.name)){const t=`${this.scoutTarget.x},${this.scoutTarget.y}`;this.visitedPoints.add(t),this.logger(`Target ${this.scoutTarget.x},${this.scoutTarget.y} scouted successfully, switching to next target`),this.setScoutTarget(null,e.getCurrentTick())}}else{const t=n.getScoutingManager().getNewScoutTarget();if(t)return this.setScoutTarget(t.asVector2(),e.getCurrentTick()),{type:"noop"};const i=this.getNextAmphibiousTarget(e,l,r);if(!i)return this.logger("No reachable amphibious exploration points found, mission ended"),g();this.setScoutTarget(i,e.getCurrentTick())}return{type:"noop"}}setScoutTarget(t,e){this.attemptsOnCurrentTarget=0,this.scoutTargetRefreshedAt=e,this.scoutTarget=t,this.scoutMinDistance=void 0,this.scoutTargetIsPermanent=!1,this.lastPosition=null,this.lastPositionCheckTick=e}getGlobalDebugText(){return"Amphibious scouting"}getPriority(){return this.priority}}class at{constructor(t=-300,e){this.lastScoutAt=t,this.eventBus=e,this.navalMode=!1,this.eventBus&&this.eventBus.subscribe((t=>{"modeChanged"===t.type&&(this.navalMode=t.isNaval)}))}getName(){return"AmphibiousScoutingMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){this.navalMode&&(t.getCurrentTick()<this.lastScoutAt+300||i.getScoutingManager().hasScoutTargets()&&(s.addMission(new nt("amphibiousScout",10,n))||(this.lastScoutAt=t.getCurrentTick())))}onMissionFailed(t,e,i,s,r,n,a){this.navalMode&&(t.getCurrentTick()<this.lastScoutAt+300||i.getScoutingManager().hasScoutTargets()&&s instanceof nt&&(n.addMission(new nt("amphibiousScout",10,a)),this.lastScoutAt=t.getCurrentTick()))}}class ot extends l{hasClearWaterLoS(e,i,s,r=1){const n=s.x-i.x,a=s.y-i.y,o=Math.max(Math.abs(n),Math.abs(a));if(0===o)return!0;for(let s=0;s<=o;s++){const h=Math.round(i.x+n*s/o),c=Math.round(i.y+a*s/o);for(let i=-r;i<=r;i++)for(let s=-r;s<=r;s++){const r=h+i,n=c+s,a=e.mapApi.getTile(r,n);if(!a)return!1;if(a.landType!==t.LandType.Clear&&a.landType!==t.LandType.Water||void 0!==a.onBridgeLandType)return!1}}return!0}findWaterFiringPoint(e,i,s,r=10){for(let n=0;n<r;n++){const r=e.generateRandom()*Math.PI*2,n=i+e.generateRandom()*(s-i),a=this.targetPos.add(new t.Vector2(Math.round(t.GameMath.cos(r)*n),Math.round(t.GameMath.sin(r)*n))),o=e.mapApi.getTile(a.x,a.y);if(o&&o.landType===t.LandType.Water&&void 0===o.onBridgeLandType&&this.hasClearWaterLoS(e,a,this.targetPos))return a}return null}pushToPointSafe(t,e,i,s,r){t.mapApi.getTile(r.x,r.y)&&e.push(D.toPoint(i,s,r))}constructor(t,e,i,s){super(t,s),this.stage="gather",this.patrolPoints=[],this.currentPatrolIdx=0,this.lastHostileTick=0,this.initialized=!1,this.lastRepositionTick=0,this.targetPos=e,this.shipyardId=null,this.rallyPoint=e,this.requiredUnits=i?{SUB:3}:{DLPH:5}}getPriority(){return 80}isUnitsLocked(){return!1}getGlobalDebugText(){return`AntiShipyard  (${this.targetPos.x},${this.targetPos.y})`}_onAiUpdate(e,i,s,r,n,a){if(!this.initialized){const i=this.getUnits(e);let s=this.targetPos;const n=e.getVisibleUnits(r.name,"self",(t=>"GAYARD"===t.name||"NAYARD"===t.name));if(n.length>0){const i=e.getUnitData(n[0]);i&&(s=new t.Vector2(i.tile.rx,i.tile.ry))}if(i.length>0){const e=i[0];s=new t.Vector2(e.tile.rx,e.tile.ry)}const a=e.mapApi.getTile(s.x,s.y),o=e.mapApi.getTile(this.targetPos.x,this.targetPos.y);let h=s;if(a&&o){const i=e.mapApi.findPath(t.SpeedType.Float,!1,{tile:a,onBridge:!1},{tile:o,onBridge:!1});if(i&&i.length>2){const e=i[Math.floor(i.length/5*4)];h=new t.Vector2(e.tile.rx,e.tile.ry)}}this.rallyPoint=h,this.initialized=!0}const o=C(this.getUnitsGameObjectData(e),(t=>t.name)),h=Object.entries(this.requiredUnits).filter((([t,e])=>(o[t]||0)<e));if(h.length>0)return p(h.map((([t])=>t)),this.getPriority());const c=this.getUnits(e);if("gather"===this.stage){if(!c.every((e=>new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(this.rallyPoint)<=4)))return c.forEach((i=>{this.pushToPointSafe(e,a,i.id,t.OrderType.Move,this.rallyPoint)})),{type:"noop"};if(0===this.patrolPoints.length)for(let e=0;e<3;e++){const i=2*Math.PI*e/3,s=this.targetPos.add(new t.Vector2(Math.round(6*t.GameMath.cos(i)),Math.round(6*t.GameMath.sin(i))));this.patrolPoints.push(s)}this.stage="approach",this.lastHostileTick=e.getCurrentTick()}if("approach"===this.stage){if(!c.every((e=>new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(this.targetPos)<=12)))return c.forEach((i=>{this.pushToPointSafe(e,a,i.id,t.OrderType.AttackMove,this.targetPos)})),{type:"noop"};this.stage="patrol"}if(n.getHostilesNearPoint2d(this.targetPos,12).length>0&&(this.lastHostileTick=e.getCurrentTick()),"patrol"===this.stage){const i=e.getVisibleUnits(r.name,"enemy").map((t=>e.getUnitData(t))).filter((e=>!!e&&(new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(this.targetPos)<=12&&e.rules.speedType===t.SpeedType.Float)));if(i.length>0)return this.lastHostileTick=e.getCurrentTick(),c.forEach((e=>{let s=i[0],r=new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(new t.Vector2(s.tile.rx,s.tile.ry));for(const n of i){const i=new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(new t.Vector2(n.tile.rx,n.tile.ry));i<r&&(s=n,r=i)}s&&a.push(D.toTargetId(e.id,t.OrderType.Attack,s.id))})),{type:"noop"};if(!(e.getCurrentTick()-this.lastHostileTick>45))return c.forEach((i=>{const s=new t.Vector2(e.generateRandomInt(-2,2),e.generateRandomInt(-2,2)),r=this.targetPos.add(s);this.pushToPointSafe(e,a,i.id,t.OrderType.Move,r)})),{type:"noop"};this.stage="destroy"}const u=e.getVisibleUnits(r.name,"enemy",(t=>"GAYARD"===t.name||"NAYARD"===t.name)).map((t=>e.getUnitData(t))).filter((t=>!!t)),l=e.getVisibleUnits(r.name,"enemy").map((t=>e.getUnitData(t))).filter((e=>!!e&&(new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(this.targetPos)<=12&&e.rules.speedType===t.SpeedType.Float)));if(l.length>0)return c.forEach((e=>{let i=l[0],s=new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(new t.Vector2(i.tile.rx,i.tile.ry));for(const r of l){const n=new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(new t.Vector2(r.tile.rx,r.tile.ry));n<s&&(i=r,s=n)}a.push(D.toTargetId(e.id,t.OrderType.Attack,i.id))})),{type:"noop"};if(u.length>0){const i=u[0];c.forEach((s=>{const r=new t.Vector2(s.tile.rx,s.tile.ry);if(this.hasClearWaterLoS(e,r,this.targetPos))a.push(D.toTargetId(s.id,t.OrderType.Attack,i.id));else{if(e.getCurrentTick()-this.lastRepositionTick<30)return;const i=this.findWaterFiringPoint(e,5,8);i?(this.pushToPointSafe(e,a,s.id,t.OrderType.AttackMove,i),this.lastRepositionTick=e.getCurrentTick()):this.pushToPointSafe(e,a,s.id,t.OrderType.AttackMove,this.targetPos)}}))}else c.forEach((i=>{this.pushToPointSafe(e,a,i.id,t.OrderType.AttackMove,this.targetPos)}));return{type:"noop"}}}class ht{maybeCreateMissions(e,i,s,r,n,a){if(r.getMissions().some((t=>t instanceof ot)))return;const o=e.getVisibleUnits(i.name,"enemy",(t=>"GAYARD"===t.name||"NAYARD"===t.name));if(0===o.length)return;const h=e.getUnitData(o[0]);if(!h)return;const c=new t.Vector2(h.tile.rx,h.tile.ry),u=i.country?.side===t.SideType.Nod,l=new ot("antiShipyard_"+e.getCurrentTick(),c,u,a);r.addMission(l)}getName(){return"AntiShipyardMissionFactory"}onMissionFailed(t,e,i,s,r,n,a){}}function ct(t,e,i,s,r){t.mapApi.getTile(r.x,r.y)&&e.push(D.toPoint(i,s,r))}class ut extends l{constructor(t,e,i,s){super(t,s),this.requiredUnits={MTNK:3},this.stage="gather",this.targetId=e,this.targetPos=i}getPriority(){return 500}isUnitsLocked(){return!1}getGlobalDebugText(){return`AntiCoast  DEST#${this.targetId}`}_onAiUpdate(e,i,s,r,n,a){const o=e.getUnitData(this.targetId);if(!o)return g();this.targetPos.set(o.tile.rx,o.tile.ry);const h=C(this.getUnitsGameObjectData(e),(t=>t.name)),c=Object.entries(this.requiredUnits).filter((([t,e])=>(h[t]||0)<e));if(c.length>0)return p(c.map((([t])=>t)),this.getPriority()),T(r.startLocation,this.getPriority());const u=this.getUnits(e);if("gather"===this.stage){const i=r.startLocation;if(!u.every((e=>new t.Vector2(e.tile.rx,e.tile.ry).distanceTo(i)<=4)))return u.forEach((s=>ct(e,a,s.id,t.OrderType.Move,i))),{type:"noop"};this.stage="attack"}return u.forEach((i=>{ct(e,a,i.id,t.OrderType.AttackMove,this.targetPos)})),{type:"noop"}}}class lt{getName(){return"AntiCoastShipMissionFactory"}maybeCreateMissions(e,i,s,r,n,a){if(r.getMissions().some((t=>t instanceof ut)))return;const o=["DEST","AEGIS","CARRIER","DRED","HYD"],h=e.getVisibleUnits(i.name,"enemy",(t=>o.includes(t.name))).filter((s=>{const r=e.getUnitData(s);if(!r)return!1;if(r.rules.movementZone!==t.MovementZone.Water)return!1;try{const s=e.mapApi.getTile(i.startLocation.x,i.startLocation.y),n=e.mapApi.getTile(r.tile.rx,r.tile.ry);if(!s||!n)return!1;const a=e.mapApi.findPath(t.SpeedType.Track,!1,{tile:s,onBridge:!1},{tile:n,onBridge:!1});if(!a||0===a.length)return!1;const o=a[0];return new t.Vector2(o.tile.rx,o.tile.ry).distanceTo(new t.Vector2(r.tile.rx,r.tile.ry))<=6}catch(t){return!1}}));if(0===h.length)return;const c=h[0],u=e.getUnitData(c);if(!u)return;const l=new t.Vector2(u.tile.rx,u.tile.ry),g=new ut("antiCoast_"+e.getCurrentTick(),c,l,a);r.addMission(g)}onMissionFailed(){}}class gt extends l{constructor(t,e,i){super(t,i),this.loggerCtx=i,this.dreadId=e}getDreadId(){return this.dreadId}getPriority(){return 101}isUnitsLocked(){return!0}getGlobalDebugText(){return`MixedEscortDRED#${this.dreadId}`}_onAiUpdate(e,i,s,r,n,a){const o=e.getUnitData(this.dreadId);if(!o)return g();const h=C(this.getUnitsGameObjectData(e),(t=>t.name)),c=h.SUB||0,u=h.HYD||0,l=[];if(c<3){const t=3-c;l.push(...Array(t).fill("SUB"))}if(u<2){const t=2-u;l.push(...Array(t).fill("HYD"))}if(l.length>0)return p(l,this.getPriority());const d=new t.Vector2(o.tile.rx,o.tile.ry);return this.getUnits(e).forEach((i=>{ct(e,a,i.id,t.OrderType.AttackMove,d)})),{type:"noop"}}}class dt{getName(){return"DreadEscortMissionFactory"}maybeCreateMissions(t,e,i,s,r,n){const a=t.getVisibleUnits(e.name,"self",(t=>"DRED"===t.name));0!==a.length&&a.forEach((t=>{if(!s.getMissions().some((e=>e instanceof gt&&e.getDreadId()===t))){const e=new gt(`escortDred_${t}`,t,n);s.addMission(e)}}))}onMissionFailed(){}}class pt extends l{constructor(t,e,i,s,r){super(t,r),this.harvesterId=e,this.radius=s,this.priority=10,this.squad=new I(i,i,s)}_onAiUpdate(e,i,s,r,n,a){const o=e.getUnitData(this.harvesterId);if(!o||o.owner!==r.name||!o.rules?.harvester)return this.logger(`Harvester ${this.harvesterId} lost  disbanding defence mission`),g();const h=new t.Vector2(o.tile.rx,o.tile.ry);this.squad.setAttackArea(h);const c=this.squad.onAiUpdate(e,s,a,r,this,n,this.logger);return"noop"!==c.type?c:0===n.getHostilesNearPoint2d(h,this.radius).map((({unitId:t})=>e.getUnitData(t))).filter((t=>!!t)).filter((t=>!S(t))).length?(this.priority=0,this.getUnitIds().length>0?b(this.getUnitIds()):{type:"noop"}):(this.priority=100,T(h,2*this.radius))}getGlobalDebugText(){return this.squad.getGlobalDebugText()}getPriority(){return this.priority}}class mt{constructor(){this.lastCheckAt=0}getName(){return"HarvesterDefenceMissionFactory"}maybeCreateMissions(e,i,s,r,n,a){e.getCurrentTick()<this.lastCheckAt+600||(this.lastCheckAt=e.getCurrentTick(),e.getVisibleUnits(i.name,"self",(t=>t.harvester)).forEach((n=>{const o=e.getUnitData(n);if(!o)return;if(0===s.getHostilesNearPoint2d(new t.Vector2(o.tile.rx,o.tile.ry),10).length)return;const h=`harvesterDefence_${n}`;if(r.getMissions().some((t=>t.getUniqueName()===h)))return;const c=new pt(h,n,i.startLocation,10,a);r.addMission(c)})))}onMissionFailed(t,e,i,s,r,n,a){}}class yt{constructor(t,e){this.eventBus=t,this.logger=e,this.missions=[],this.unitIdToMission=new Map,this.requestedUnitTypes=new Map,this.forceDisbandedMissions=[],this.missionFactories=(t=>[new M,new z,new W(t),new X,new J,new st(-300,t),new at(-300,t),new ht,new lt,new mt,new dt])(this.eventBus)}updateUnitIds(t){this.unitIdToMission=new Map,this.missions.forEach((e=>{const i=[];e.getUnitIds().forEach((s=>{this.unitIdToMission.has(s)?this.logger(`WARNING: unit ${s} is in multiple missions, please debug.`):t.getGameObjectData(s)?this.unitIdToMission.set(s,e):i.push(s)})),i.forEach((t=>e.removeUnit(t)))}))}onAiUpdate(e,i,s,r,n){this.missions=this.missions.filter((t=>t.isActive())),this.updateUnitIds(e);const a=new N,o=this.missions.map((t=>({mission:t,action:t.onAiUpdate(e,i,s,r,n,a)}))),h=new Map,c=[];this.forceDisbandedMissions.forEach((t=>h.set(t,null))),this.forceDisbandedMissions=[],o.filter(d).forEach((t=>{this.logger(`Mission ${t.mission.getUniqueName()} disbanding as requested.`),t.mission.getUnitIds().forEach((t=>{this.unitIdToMission.delete(t),s.setUnitDebugText(t,void 0)})),h.set(t.mission.getUniqueName(),t.action.reason)})),this.missions.filter((t=>h.has(t.getUniqueName()))).forEach((t=>{const e=h.get(t.getUniqueName());this.logger(`mission disbanded: ${t.getUniqueName()}, reason: ${e}`),c.push({mission:t,reason:e}),t.endMission(h.get(t.getUniqueName()))})),this.missions=this.missions.filter((t=>!h.has(t.getUniqueName()))),o.filter(w).forEach((t=>{t.action.unitIds.forEach((e=>{this.unitIdToMission.get(e)?.getUniqueName()===t.mission.getUniqueName()&&this.removeUnitFromMission(t.mission,e,s)}))}));const u=o.filter(f).reduce(((t,e)=>{const{unitIds:i}=e.action;return i.forEach((i=>{t.hasOwnProperty(i)?t[i].action.priority>t[i].action.priority&&(t[i]=e):t[i]=e})),t}),{}),l=Object.entries(u).flatMap((([t,i])=>{const r=Number.parseInt(t),n=e.getGameObjectData(r),{mission:a}=i,o=a.getUniqueName();return n?this.unitIdToMission.has(r)?[]:(this.addUnitToMission(a,n,s),[{unitName:n?.name,mission:a.getUniqueName()}]):(this.logger(`mission ${o} requested non-existent unit ${r}`),[])})).reduce(((t,e)=>(t[e.mission]||(t[e.mission]={}),t[e.mission][e.unitName]||(t[e.mission][e.unitName]=0),t[e.mission][e.unitName]=t[e.mission][e.unitName]+1,t)),{});Object.entries(l).forEach((([t,e])=>{this.logger(`Mission ${t} received: ${Object.entries(e).map((([t,e])=>t+" x "+e)).join(", ")}`)}));const g=o.filter(m).reduce(((t,e)=>{const{unitNames:i}=e.action;return i.forEach((i=>{t.hasOwnProperty(i)?t[i].action.priority>t[i].action.priority&&(t[i]=e):t[i]=e})),t}),{}),p=o.filter(A),y=e.getVisibleUnits(r.name,"self").map((t=>e.getGameObjectData(t))).filter((t=>!!t)).map((t=>({unit:t,mission:this.unitIdToMission.get(t.id)}))).filter((t=>!t.mission||!1===t.mission.isUnitsLocked()));y.sort(((t,e)=>(t.mission?.getPriority()??0)-(e.mission?.getPriority()??0)));const T=y.flatMap((({unit:e,mission:i})=>{if(g.hasOwnProperty(e.name)){const{mission:t}=g[e.name];if(i){if(i===t||i.getPriority()>t.getPriority())return[];this.removeUnitFromMission(i,e.id,s)}return this.logger(`granting unit ${e.id}#${e.name} to mission ${t.getUniqueName()}`),this.addUnitToMission(t,e,s),delete g[e.name],[{unitName:e.name,missionName:t.getUniqueName(),method:"type"}]}if(p.length>0){const r=p.find((i=>{var s;return!!(s=e)&&!!s?.rules?.isSelectableCombatant&&i.action.point.distanceTo(new t.Vector2(e.tile.rx,e.tile.ry))<=i.action.radius}));if(r){if(i){if(i===r.mission||i.getPriority()>r.mission.getPriority())return[];this.removeUnitFromMission(i,e.id,s)}return this.addUnitToMission(r.mission,e,s),[{unitName:e.name,missionName:r.mission.getUniqueName(),method:"grab"}]}}return[]})).reduce(((t,e)=>(t[e.missionName]||(t[e.missionName]={}),t[e.missionName][e.unitName]||(t[e.missionName][e.unitName]={grab:0,type:0}),t[e.missionName][e.unitName][e.method]=t[e.missionName][e.unitName][e.method]+1,t)),{});Object.entries(T).forEach((([t,e])=>{this.logger(`Mission ${t} received: ${Object.entries(e).flatMap((([t,e])=>Object.entries(e).filter((([,t])=>t>0)).map((([e,i])=>t+" x "+i+" (by "+e+")")))).join(", ")}`)})),this.updateRequestedUnitTypes(g),a.resolve(s),this.missionFactories.forEach((t=>{t.maybeCreateMissions(e,r,n,this,i,this.logger),c.forEach((({reason:i,mission:s})=>{t.onMissionFailed(e,r,n,s,i,this,this.logger)}))}))}updateRequestedUnitTypes(t){const e=Array.from(this.requestedUnitTypes.keys());for(const t of e){const e=.75*this.requestedUnitTypes.get(t)-1;e>.5?this.requestedUnitTypes.set(t,e):this.requestedUnitTypes.delete(t)}Object.entries(t).forEach((([t,e])=>{const i=this.requestedUnitTypes.get(t);this.requestedUnitTypes.set(t,i?Math.max(i,e.action.priority):e.action.priority)}))}getRequestedUnitTypes(){return this.requestedUnitTypes}addUnitToMission(t,e,i){t.addUnit(e.id),this.unitIdToMission.set(e.id,t),i.setUnitDebugText(e.id,t.getUniqueName()+"_"+e.id)}removeUnitFromMission(t,e,i){t.removeUnit(e),this.unitIdToMission.delete(e),i.setUnitDebugText(e,void 0)}addMission(t){return this.missions.some((e=>e.getUniqueName()===t.getUniqueName()))?null:(this.logger(`Added mission: ${t.getUniqueName()}`),this.missions.push(t),t)}disbandMission(t){this.forceDisbandedMissions.push(t)}getGlobalDebugText(t){let e="";return this.missions.forEach((i=>{var s;this.logger(`Mission ${i.getUniqueName()}: ${Object.entries((s=i.getUnitIds(),C(s,(e=>t.getGameObjectData(e)?.name)))).map((([t,e])=>`${t} x ${e}`)).join(", ")}`);const r=i.getGlobalDebugText();r&&(e+=i.getUniqueName()+": "+r+"\n")})),e}updateDebugText(t){this.missions.forEach((e=>{e.getUnitIds().forEach((i=>t.setUnitDebugText(i,`${i}: ${e.getUniqueName()}`)))}))}getMissions(){return this.missions}}class ft{constructor(t,e,i,s){this.basePriority=t,this.baseAmount=e,this.groundStrength=i,this.limit=s}getPlacementLocation(t,e,i){return((t,e,i)=>{const{startLocation:r,name:n}=e,a=t.getPlayers().filter((e=>e!==n&&!t.areAlliedPlayers(e,n))).map((e=>{const i=t.getPlayerData(e);return s(t,r,i.startLocation,4,16,1.5)}));if(0===a.length)return;const o=a[Math.floor(t.generateRandom()*a.length)];return _t(t,e,o,i,!1,2)})(t,e,i)}getPriority(t,e,i,s){const r=Ut(t,e,i);if(r>=this.limit)return 0;if(s){let t=s.totalAvailableAntiGroundFirepower+s.totalDefensivePower+this.groundStrength;return s.totalOffensiveLandThreat>1.1*t?this.basePriority*(s.totalOffensiveLandThreat/Math.max(1,t)):0}const n=this.groundStrength/i.cost*1e3;return this.basePriority*(1-r/this.baseAmount)*n}getMaxCount(t,e,i,s){return null}}class Tt{constructor(t,e,i,s){this.basePriority=t,this.artilleryPower=e,this.antiGroundPower=i,this.baseAmount=s}getPlacementLocation(t,e,i){}getPriority(t,e,i,s){return 0}getMaxCount(t,e,i,s){return null}}class At{constructor(t,e,i=1,s=0){this.basePriority=t,this.baseAmount=e,this.antiGroundPower=i,this.antiAirPower=s}getPlacementLocation(t,e,i){}getPriority(t,e,i,s){return 0}getMaxCount(t,e,i,s){return null}}class bt{constructor(t,e,i){this.basePriority=t,this.maxNeeded=e,this.onlyBuildWhenFloatingCreditsAmount=i}getPlacementLocation(t,e,i){return _t(t,e,e.startLocation,i)}getPriority(t,e,i,s){const r=Ut(t,e,i);if(r>=(this.getMaxCount(t,e,i,s)??this.maxNeeded))return-100;const n=this.basePriority*(1-r/this.maxNeeded);return this.onlyBuildWhenFloatingCreditsAmount&&e.credits<this.onlyBuildWhenFloatingCreditsAmount?n*(e.credits/this.onlyBuildWhenFloatingCreditsAmount):n}getMaxCount(t,e,i,s){return this.maxNeeded}}class wt{constructor(t,e,i=1,s=0){this.basePriority=t,this.baseAmount=e,this.antiGroundPower=i,this.antiAirPower=s}getPlacementLocation(t,e,i){}getPriority(t,e,i,s){return 0}getMaxCount(t,e,i,s){return null}}class xt{getPlacementLocation(t,e,i){return _t(t,e,e.startLocation,i)}getPriority(t,e,i){return e.power.total<e.power.drain?100:e.power.total<e.power.drain+i.power/2?20:0}getMaxCount(t,e,i,s){return null}}var Mt=r(295);class Pt extends bt{constructor(t,e,i){super(t,e,i)}getPlacementLocation(e,i,s){let r=i.startLocation;var n,a;let o=e.mapApi.getAllTilesResourceData();for(let e=0;e<o.length;++e){let i=o[e];if(i.spawnsOre){let e=t.GameMath.sqrt(t.GameMath.pow(r.x-i.tile.rx,2)+t.GameMath.pow(r.y-i.tile.ry,2));(null==a||e<a)&&(a=e,n=i.tile)}}return n&&(r=new Mt.Vector2(n.rx,n.ry)),_t(e,i,r,s)}getMaxCount(t,e,i,s){const r=t.getVisibleUnits(e.name,"self",(t=>t.harvester)).length;return Math.max(1,2*r)}}class St extends wt{constructor(t,e,i){super(t,e,0,0),this.minNeeded=i}getPriority(t,e,i,s){const r=t.getVisibleUnits(e.name,"self",(t=>t.refinery)).length,n=t.getVisibleUnits(e.name,"self",(t=>t.harvester)).length,a=n<this.minNeeded?3:n>3*r?0:1;return this.basePriority*(r/Math.max(n/2,1))*a}}class vt{constructor(t,e,i){this.basePriority=t,this.baseAmount=e,this.airStrength=i}getPlacementLocation(t,e,i){let r=e.startLocation,n=t.getPlayers(),a=[];for(let i=0;i<n.length;++i){let o=n[i];if(o==e.name)continue;let h=t.getPlayerData(o);a.push(s(t,r,h.startLocation,4,16,1.5))}let o=a[Math.floor(t.generateRandom()*a.length)];return _t(t,e,o,i,!1,0)}getPriority(t,e,i,s){if(s){let t=s.totalAvailableAntiAirFirepower+this.airStrength;return s.totalOffensiveAirThreat>1.1*t?this.basePriority*(s.totalOffensiveAirThreat/Math.max(1,t)):0}const r=this.airStrength/i.cost*1e3,n=Ut(t,e,i);return this.basePriority*(1-n/this.baseAmount)*r}getMaxCount(t,e,i,s){return null}}class kt extends bt{constructor(t,e,i){super(t,e,i)}getPlacementLocation(t,e,i){return _t(t,e,e.startLocation,i,!0,1)}getPriority(t,e,i,s){return super.getPriority(t,e,i,s)}}class Ct{constructor(t,e,i=1,s=0,r=1){this.basePriority=t,this.baseAmount=e,this.antiGroundPower=i,this.antiAirPower=s,this.antiNavalPower=r}getPlacementLocation(t,e,i){}getPriority(t,e,i,s){return 0}getMaxCount(t,e,i,s){return null}}function Ut(t,e,i){return t.getVisibleUnits(e.name,"self",(t=>t==i)).length}function Dt(t,e,i,s){return{x:t.x-i-(s?.width||0),y:t.y-i-(s?.height||0),width:e.width+2*i+(s?.width||0),height:e.height+2*i+(s?.height||0)}}function Nt(e,i,s){return e.mapApi.getTilesInRect(i).filter((e=>!s||e.landType===t.LandType.Water))}function Et(e,i,s,r){var n=e-s,a=i-r;let o=n*n+a*a;return 0===o?0:t.GameMath.sqrt(o)}function _t(e,i,s,r,n=!1,a=1){if(!e.getBuildingPlacementData(r.name))return;const o=(h=s,c=function(e,i,s,r,n){const a=e.getBuildingPlacementData(s.name),{width:o,height:h}=a.foundation,c=[],u=e.getVisibleUnits(i.name,"self",(e=>e.type===t.ObjectType.Building)),l=new Set;for(let i of u){const u=e.getUnitData(i);if(!u?.rules?.baseNormal)continue;const{foundation:g,tile:d}=u,p=new t.Vector2(d.rx,d.ry),m={width:g?.width,height:g?.height},y=Nt(e,Dt(p,m,s.adjacent,a.foundation),r);if(0===y.length)continue;c.push(...y);const f=Dt(new t.Vector2(p.x-(o-1),p.y-(h-1)),{width:m.width+(o-1),height:m.height+(h-1)},n),T=y.filter((t=>t.rx>=f.x&&t.rx<f.x+f.width&&t.ry>=f.y&&t.ry<f.y+f.height));T.forEach((t=>l.add(t.id)))}var g,d;return(g=c,d=t=>t.id,Object.values(g.reduce(((t,e)=>{const i=d(e);return t[i]||(t[i]=e),t}),{}))).filter((t=>!l.has(t.id)))}(e,i,r,n,a),c.map((t=>({tile:t,distance:Et(t.rx,t.ry,h.x,h.y)}))).sort(((t,e)=>t.distance-e.distance)));var h,c;for(let t of o)if(t.tile&&e.canPlaceBuilding(i.name,r.name,t.tile))return t.tile}const Rt=new Map([["GAPOWR",new xt],["GAREFN",new Pt(10,2)],["GAWEAP",new bt(15,2)],["GAPILE",new bt(12,1)],["CMIN",new St(15,3,2)],["GADEPT",new bt(1,1,1e4)],["GAAIRC",new bt(10,1,500)],["AMRADR",new bt(10,1,500)],["GATECH",new bt(20,1,4e3)],["GAYARD",new kt(10,2)],["GAPILL",new ft(2,1,5,5)],["ATESLA",new ft(2,1,10,3)],["NASAM",new vt(2,1,5)],["GAWALL",new ft(0,0,0,0)],["E1",new wt(2,2,.2,0)],["ENGINEER",new wt(1,0,0)],["MTNK",new wt(10,3,2,0)],["MGTK",new wt(10,1,2.5,0)],["FV",new wt(5,2,.5,1)],["JUMPJET",new At(10,1,1,1)],["ORCA",new At(7,1,2,0)],["SREF",new Tt(10,5,3,3)],["CLEG",new wt(0,0)],["SHAD",new wt(0,0)],["NAPOWR",new xt],["NAREFN",new Pt(10,2)],["NAWEAP",new bt(15,2)],["NAHAND",new bt(12,1)],["HARV",new St(15,3,2)],["NADEPT",new bt(1,1,1e4)],["NARADR",new bt(10,1,500)],["NANRCT",new xt],["NAYARD",new kt(10,3)],["NATECH",new bt(20,1,4e3)],["NALASR",new ft(2,1,5,5)],["NAFLAK",new vt(2,1,5)],["TESLA",new ft(2,1,10,3)],["NAWALL",new ft(0,0,0,0)],["E2",new wt(2,2,.2,0)],["SENGINEER",new wt(1,0,0)],["FLAKT",new wt(2,2,.1,.3)],["YURI",new wt(1,1,1,0)],["DOG",new wt(1,1,0,0)],["HTNK",new wt(10,3,3,0)],["APOC",new wt(6,1,5,0)],["HTK",new wt(5,2,.33,1.5)],["ZEP",new At(5,1,5,1)],["V3",new Tt(9,10,0,3)],["DEST",new Ct(9,4,2,0,1)],["AEGIS",new Ct(8,0,0,6,0)],["CARRIER",new Ct(9,1,4,1,1)],["DLPH",new Ct(5,2,0,0,2)],["SUB",new Ct(9,4,0,0,4)],["HYD",new Ct(8,0,0,1.5,.1)],["DRED",new Ct(9,0,4,0,1)],["SQD",new Ct(5,2,0,0,5)]]),$t=[t.QueueType.Structures,t.QueueType.Armory,t.QueueType.Infantry,t.QueueType.Vehicles,t.QueueType.Aircrafts,t.QueueType.Ships],Vt=e=>{switch(e){case t.QueueType.Structures:return"Structures";case t.QueueType.Armory:return"Armory";case t.QueueType.Infantry:return"Infantry";case t.QueueType.Vehicles:return"Vehicles";case t.QueueType.Aircrafts:return"Aircrafts";case t.QueueType.Ships:return"Ships";default:return"Unknown"}};class Ot{constructor(t){this.eventBus=t,this.queueStates=[],this.lastRepairCheckAt=0,this.navalMode=!1,this.lastCancelTicks=new Map,this.eventBus.subscribe((t=>{"modeChanged"===t.type&&(this.navalMode=t.isNaval)}))}onAiUpdate(t,e,i,s,r,n,a){this.queueStates=$t.map((i=>{const o=e.getAvailableObjects(i),h=this.getPrioritiesForBuildingOptions(t,o,r,s,n,a,i),c=h.length>0?h[h.length-1]:void 0;return{queue:i,items:h,topItem:c&&c.priority>0?c:void 0}}));const o=this.queueStates.map((t=>t.topItem?.priority)).reduce(((t,e)=>t+e),0),h=this.queueStates.map((t=>t.topItem?.unit.cost)).reduce(((t,e)=>t+e),0);this.queueStates.forEach((n=>{this.updateBuildQueue(t,e,i,s,r,n.queue,n.topItem,o,h,a)})),s.credits>0&&t.getCurrentTick()>this.lastRepairCheckAt+30&&(t.getVisibleUnits(s.name,"self",(t=>t.repairable)).forEach((e=>{const s=t.getUnitData(e);s&&s.hitPoints&&s.maxHitPoints&&!s.hasWrenchRepair&&s.hitPoints<s.maxHitPoints&&i.toggleRepairWrench(e)})),this.lastRepairCheckAt=t.getCurrentTick())}updateBuildQueue(e,i,s,r,n,a,o,h,c,u){const l=r.credits,g=i.getQueueData(a);if(g.status==t.QueueStatus.Idle)void 0!==o&&(u(`Decision (${Vt(a)}): ${o.unit.name}`),s.queueForProduction(a,o.unit.name,o.unit.type,1));else if(g.status==t.QueueStatus.Ready&&g.items.length>0){const i=g.items[0].rules;if(a==t.QueueType.Structures||a==t.QueueType.Armory){let t=this.getBestLocationForStructure(e,r,i);void 0!==t?(u(`Completed: ${Vt(a)}: ${i.name}, placing at ${t.rx},${t.ry}`),s.placeBuilding(i.name,t.rx,t.ry)):(u(`Completed: ${Vt(a)}: ${i.name} but nowhere to place it`),"GAYARD"!==i.name&&"NAYARD"!==i.name||this.eventBus.publish({type:"yardFailed",player:r.name}),s.unqueueFromProduction(a,i.name,i.type,1))}}else if(g.status==t.QueueStatus.Active&&g.items.length>0&&null!=o){const t=g.items[0].rules;if(o.unit!=t){let i=this.getPriorityForBuildingOption(t,e,r,n,a),h=o.priority;const c=this.lastCancelTicks.get(a)??0,l=900;h>3*i&&e.getCurrentTick()-c>l&&(u(`Dequeueing queue ${Vt(g.type)} unit ${t.name} because ${o.unit.name} has 2x higher priority.`),s.unqueueFromProduction(g.type,t.name,t.type,1),this.lastCancelTicks.set(a,e.getCurrentTick()))}else c>l&&o.priority<.25*h&&(u(`Pausing queue ${Vt(g.type)} because weight is low (${o.priority}/${h})`),s.pauseProduction(g.type))}else g.status==t.QueueStatus.OnHold&&(l>=c?(u(`Resuming queue ${Vt(g.type)} because credits are high`),s.resumeProduction(g.type)):o&&o.priority>=.25*h&&(u(`Resuming queue ${Vt(g.type)} because weight is high (${o.priority}/${h})`),s.resumeProduction(g.type)))}getPrioritiesForBuildingOptions(t,e,i,s,r,n,a){let o=[];return e.forEach((e=>{const n=e.name,h="GAYARD"===n||"NAYARD"===n,c="GAWEAP"===n||"NAWEAP"===n;if(h||c){const e=t.getVisibleUnits(s.name,"self",(t=>t.name===n)).length;if(h){if(!this.navalMode)return;if(e>=4)return}else if(c&&e>=(this.navalMode?1:4))return}const u=this.getPriorityForBuildingOption(e,t,s,i,a),l=Math.max(u,r.get(e.name)??u),g=l+1e-5*t.generateRandom();l>0&&o.push({unit:e,priority:g})})),o=o.sort(((t,e)=>t.priority-e.priority)),o}getPriorityForBuildingOption(e,i,s,r,n){if(Rt.has(e.name))return Rt.get(e.name).getPriority(i,s,e,r);{const r=i.getVisibleUnits(s.name,"self",(t=>t==e)).length;return n!==t.QueueType.Structures&&n!==t.QueueType.Armory||0!==r?0-r:1}}getBestLocationForStructure(t,e,i){return Rt.has(i.name)?Rt.get(i.name).getPlacementLocation(t,e,i):_t(t,e,e.startLocation,i)}getGlobalDebugText(e,i){return`Production: ${$t.reduce(((e,s)=>{if(0===i.getQueueData(s).size)return e;const r=i.getQueueData(s).status===t.QueueStatus.OnHold;return e+" ["+Vt(s)+(r?" PAUSED":"")+": "+i.getQueueData(s).items.map((t=>t.rules.name+(t.quantity>1?"x"+t.quantity:"")))+"]"}),"")}\n${this.queueStates.filter((t=>t.items.length>0)).map((t=>{const e=t.items.map((t=>t.unit.name+"("+Math.round(10*t.priority)/10+")")).join(", ");return`${Vt(t.queue)} Prios: ${e}\n`})).join("")}`}}class It{constructor(t,e,i,s,r,n,a,o,h){this.certainty=t,this.totalOffensiveLandThreat=e,this.totalOffensiveAirThreat=i,this.totalOffensiveAntiAirThreat=s,this.totalDefensiveThreat=r,this.totalDefensivePower=n,this.totalAvailableAntiGroundFirepower=a,this.totalAvailableAntiAirFirepower=o,this.totalAvailableAirPower=h}}function Lt(t,e){return qt(t,e,(t=>t.isAntiGround))}function Gt(t,e){return qt(t,e,(t=>t.isAntiAir))}function qt(t,e,i){const s=u(t,e);if(!s||!s.primary&&!s.secondary)return!1;const r=s.primary?t.rulesApi.getWeapon(s.primary):null,n=Bt(t,r);if(n&&i(n))return!0;const a=s.secondary?t.rulesApi.getWeapon(s.secondary):null,o=Bt(t,a);return!(!o||!i(o))}function Bt(t,e){return e?t.rulesApi.getProjectile(e.projectile):null}function Ft(e,i){let s=0;return i.forEach((i=>{const r=e.getGameObjectData(i);r&&(s+=function(e,i){const s=u(e,i.id);if(!s)return 0;const r=i?.hitPoints||0,n=i?.maxHitPoints||0;let a=0;const o=r/Math.max(1,n);if(s.primary){const i=e.rulesApi.getWeapon(s.primary);a+=o*((i.damage+1)*t.GameMath.sqrt(i.range+1))/Math.max(i.rof,1)}if(s.secondary){const i=e.rulesApi.getWeapon(s.secondary);a+=o*((i.damage+1)*t.GameMath.sqrt(i.range+1))/Math.max(i.rof,1)}return Math.min(800,a)}(e,r))})),s}class jt{constructor(t,e=0){this.bounds={x:t.x||0,y:t.y||0,width:t.width,height:t.height},this.maxObjects="number"==typeof t.maxObjects?t.maxObjects:10,this.maxLevels="number"==typeof t.maxLevels?t.maxLevels:4,this.level=e,this.objects=[],this.nodes=[]}getIndex(t){return t.qtIndex(this.bounds)}split(){const t=this.level+1,e=this.bounds.width/2,i=this.bounds.height/2,s=this.bounds.x,r=this.bounds.y,n=[{x:s+e,y:r},{x:s,y:r},{x:s,y:r+i},{x:s+e,y:r+i}];for(let s=0;s<4;s++)this.nodes[s]=new jt({x:n[s].x,y:n[s].y,width:e,height:i,maxObjects:this.maxObjects,maxLevels:this.maxLevels},t)}insert(t){if(this.nodes.length){const e=this.getIndex(t);for(let i=0;i<e.length;i++)this.nodes[e[i]].insert(t)}else if(this.objects.push(t),this.objects.length>this.maxObjects&&this.level<this.maxLevels){this.nodes.length||this.split();for(let t=0;t<this.objects.length;t++){const e=this.getIndex(this.objects[t]);for(let i=0;i<e.length;i++)this.nodes[e[i]].insert(this.objects[t])}this.objects=[]}}retrieve(t){const e=this.getIndex(t);let i=this.objects;if(this.nodes.length)for(let s=0;s<e.length;s++)i=i.concat(this.nodes[e[s]].retrieve(t));return 0===this.level?Array.from(new Set(i)):i}remove(t,e=!1){const i=this.objects.indexOf(t);i>-1&&this.objects.splice(i,1);for(let e=0;e<this.nodes.length;e++)this.nodes[e].remove(t);return 0!==this.level||e||this.join(),-1!==i}update(t,e=!1){this.remove(t,e),this.insert(t)}join(){let t=Array.from(this.objects);for(let e=0;e<this.nodes.length;e++){const i=this.nodes[e].join();t=t.concat(i)}const e=Array.from(new Set(t));if(e.length<=this.maxObjects){this.objects=e;for(let t=0;t<this.nodes.length;t++)this.nodes[t].objects=[];this.nodes=[]}return t}clear(){this.objects=[];for(let t=0;t<this.nodes.length;t++)this.nodes.length&&this.nodes[t].clear();this.nodes=[]}}class Ht{constructor(t){this.x=t.x,this.y=t.y,this.r=t.r,this.data=t.data}qtIndex(t){const e=[],i=t.width/2,s=t.height/2,r=t.x+i,n=t.y+s,a=[[r,t.y],[t.x,t.y],[t.x,n],[r,n]];for(let t=0;t<a.length;t++)Ht.intersectRect(this.x,this.y,this.r,a[t][0],a[t][1],a[t][0]+i,a[t][1]+s)&&e.push(t);return e}static intersectRect(t,e,i,s,r,n,a){const o=t-Math.max(s,Math.min(t,n)),h=e-Math.max(r,Math.min(e,a));return o*o+h*h<i*i}}var Qt=r(82);class Wt{constructor(t,e,i=!1){if(this.permanent=i,e.hasOwnProperty("x")&&e.hasOwnProperty("y"))this._targetPoint=e;else{if(!e.hasOwnProperty("sectorStartPoint"))throw new TypeError(`invalid object passed as target: ${e}`);this._targetSector=e}this._priority=t}get priority(){return this._priority}asVector2(){return this._targetPoint??this._targetSector?.sectorStartPoint??null}get targetSector(){return this._targetSector}get isPermanent(){return this.permanent}}class Yt{constructor(t){this.logger=t,this.queuedRadius=2,this.scoutingQueue=new Qt.PriorityQueue(((t,e)=>e.priority-t.priority))}addRadiusToScout(e,i,s,r,n){const{x:a,y:o}=i,{width:h,height:c}=s.getSectorBounds(),u=s.getSectorCoordinatesForWorldPosition(a,o);if(u)for(let i=Math.max(0,u.sectorX-r);i<Math.min(h,u.sectorX+r);++i)for(let a=Math.max(0,u.sectorY-r);a<Math.min(c,u.sectorY+r);++a){if(i===u?.sectorX&&a===u?.sectorY)continue;const r=t.GameMath.pow(i-u.sectorX,2)+t.GameMath.pow(a-u.sectorY,2),o=s.getSector(i,a);if(o){const i=[];i.push(o.sectorStartPoint),i.push(new t.Vector2(o.sectorStartPoint.x+Math.floor(4),o.sectorStartPoint.y+Math.floor(4))),i.push(new t.Vector2(Math.min(o.sectorStartPoint.x+8-1,s.getMapBounds().width-1),Math.min(o.sectorStartPoint.y+8-1,s.getMapBounds().height-1))),i.forEach((t=>{if(!e.mapApi.getTile(t.x,t.y))return;const i=new Wt(n-r,t);this.scoutingQueue.enqueue(i)}))}}}ensureEnemyStartLocations(t,e){t.mapApi.getStartingLocations().filter((t=>t!==e.startLocation)).forEach((i=>{const s=t.mapApi.getTile(i.x,i.y);s&&(t.mapApi.isVisibleTile(s,e.name)||(i.x,i.y,this.scoutingQueue.toArray().some((t=>{const e=t.asVector2();return e&&e.x===i.x&&e.y===i.y}))||(this.logger(`Re-queue unseen enemy spawn at ${i.x},${i.y}`),this.scoutingQueue.enqueue(new Wt(100,i,!0)))))}))}onGameStart(t,e,i){t.mapApi.getStartingLocations().filter((i=>{if(i==e.startLocation)return!1;let s=t.mapApi.getTile(i.x,i.y);return!!s&&!t.mapApi.isVisibleTile(s,e.name)})).map((t=>new Wt(100,t,!0))).forEach((t=>{this.logger(`Adding ${t.asVector2()?.x},${t.asVector2()?.y} to initial scouting queue`),this.scoutingQueue.enqueue(t)})),this.addRadiusToScout(t,e.startLocation,i,2,1e3)}onAiUpdate(t,e,i){this.ensureEnemyStartLocations(t,e);const s=this.scoutingQueue.front();if(!s)return;const r=s.asVector2();if(!r)return void this.scoutingQueue.dequeue();const{x:n,y:a}=r,o=t.mapApi.getTile(n,a);o&&t.mapApi.isVisibleTile(o,e.name)&&(this.logger("head point is visible, dequeueing"),this.scoutingQueue.dequeue());const h=Math.floor(t.getCurrentTick()/9e3);h>this.queuedRadius&&(this.logger(`expanding scouting radius from ${this.queuedRadius} to ${h}`),this.addRadiusToScout(t,e.startLocation,i,h,1e3),this.queuedRadius=h)}getNewScoutTarget(){return this.scoutingQueue.dequeue()}hasScoutTargets(){return!this.scoutingQueue.isEmpty()}}class zt{constructor(t,e,i,s){this.threatCache=t,this.sectorCache=e,this.mainRallyPoint=i,this.logger=s,this._shouldAttack=!1;const{width:r,height:n}=e.getMapBounds();this.hostileQuadTree=new jt({width:r,height:n}),this.scoutingManager=new Yt(s)}getHostilesNearPoint2d(t,e){return this.getHostilesNearPoint(t.x,t.y,e)}getHostilesNearPoint(e,i,s){return this.hostileQuadTree.retrieve(new Ht({x:e,y:i,r:s})).map((({x:t,y:e,data:i})=>({x:t,y:e,unitId:i}))).filter((({x:r,y:n})=>new t.Vector2(r,n).distanceTo(new t.Vector2(e,i))<=s)).filter((({unitId:t})=>!!t))}getThreatCache(){return this.threatCache}getSectorCache(){return this.sectorCache}getMainRallyPoint(){return this.mainRallyPoint}getScoutingManager(){return this.scoutingManager}shouldAttack(){return this._shouldAttack}checkShouldAttack(t,e){let i=1.1*t.totalAvailableAntiGroundFirepower,s=1.1*(e*t.totalOffensiveLandThreat+t.totalDefensiveThreat),r=1.1*t.totalAvailableAirPower,n=1.1*(e*t.totalOffensiveAntiAirThreat+t.totalDefensiveThreat);return i>s||r>n}onGameStart(t,e){this.scoutingManager.onGameStart(t,e,this.sectorCache)}onAiUpdate(e,i){const r=this.sectorCache;r.updateSectors(e.getCurrentTick(),8,e.mapApi,i),this.scoutingManager.onAiUpdate(e,i,r);let n=r?.getSectorUpdateRatio(e.getCurrentTick()-60*e.getTickRate());n&&n<1&&this.logger(100*n+"% of sectors updated in last 60 seconds.");const a=e.getVisibleUnits(i.name,"enemy");try{const t=a.map((t=>e.getGameObjectData(t))).filter((t=>void 0!==t));o=this.hostileQuadTree,h=t,o.clear(),h.forEach((t=>{o.insert(new Ht({x:t.tile.rx,y:t.tile.ry,r:1,data:t.id}))}))}catch(t){console.error("caught error",a)}var o,h;if(e.getCurrentTick()%30==0){let s=r?.getOverallVisibility();if(s){this.logger(Math.round(1e3*s)/10+"% of tiles visible. Calculating threat."),this.threatCache=function(e,i,s){let r=e.getVisibleUnits(i.name,"enemy",(e=>e.type==t.ObjectType.Vehicle||e.type==t.ObjectType.Infantry)),n=e.getVisibleUnits(i.name,"enemy",(e=>e.movementZone==t.MovementZone.Fly)),a=e.getVisibleUnits(i.name,"enemy",(e=>e.type==t.ObjectType.Building)).filter((t=>Lt(e,t))),o=e.getVisibleUnits(i.name,"enemy",(e=>e.type!=t.ObjectType.Building)).filter((t=>Gt(e,t))),h=e.getVisibleUnits(i.name,"self",(t=>t.isSelectableCombatant)).filter((t=>Lt(e,t))),c=e.getVisibleUnits(i.name,"self",(e=>e.isSelectableCombatant||e.type===t.ObjectType.Building)).filter((t=>Gt(e,t))),u=e.getVisibleUnits(i.name,"self",(e=>e.type===t.ObjectType.Building)).filter((t=>Lt(e,t))),l=e.getVisibleUnits(i.name,"self",(e=>e.movementZone==t.MovementZone.Fly&&e.isSelectableCombatant)),g=Ft(e,r),d=Ft(e,n),p=Ft(e,o),m=Ft(e,a),y=Ft(e,h),f=Ft(e,c),T=Ft(e,l),A=Ft(e,u);return new It(s,g,d,p,m,A,y,f,T)}(e,i,s);const r=Math.max(0,1-e.getCurrentTick()/108e3);this.logger(`Game length multiplier: ${r}`),this._shouldAttack?(this._shouldAttack=this.checkShouldAttack(this.threatCache,.75*r),this._shouldAttack||this.logger("Globally switched to defence mode.")):(this._shouldAttack=this.checkShouldAttack(this.threatCache,1.25*r),this._shouldAttack&&this.logger("Globally switched to attack mode."))}}if(e.getCurrentTick()%300==0){const r=e.getPlayers().filter((t=>t!==i.name&&!e.areAlliedPlayers(i.name,t))),n=e.getPlayerData(r[0]),a=function(e,i){const s=i.startLocation.x,r=i.startLocation.y;for(let i=0;i<=5;i++){const n=[{x:s,y:r},{x:s+i,y:r},{x:s-i,y:r},{x:s,y:r+i},{x:s,y:r-i}];for(const{x:i,y:s}of n){const r=e.mapApi.getTile(i,s);if(r&&e.mapApi.isPassableTile(r,t.SpeedType.Track,!1,!1))return r}}return e.mapApi.getTile(s,r)??null}(e,i),o=e.mapApi.getTile(n.startLocation.x,n.startLocation.y),h=s(e,i.startLocation,n.startLocation,9,9,0);if(a&&o)try{const i=e.mapApi.findPath(t.SpeedType.Track,!1,{tile:a,onBridge:!1},{tile:o,onBridge:!1},{bestEffort:!0});if(i&&i.length>0){const e=i[Math.floor(i.length/10*9)].tile;this.mainRallyPoint=new t.Vector2(e.rx,e.ry),this.logger(`Rally point set to path 70% position: (${e.rx}, ${e.ry}), path length: ${i.length}`)}else this.mainRallyPoint=h,this.logger(`No path found, using fallback rally point: (${this.mainRallyPoint.x}, ${this.mainRallyPoint.y})`)}catch(t){this.mainRallyPoint=h,this.logger(`Path finding error, using fallback rally point: ${t}`)}else this.mainRallyPoint=h,this.logger("Cannot get tiles, using fallback rally point")}}getGlobalDebugText(){if(this.threatCache)return`Threat LAND: Them ${Math.round(this.threatCache.totalOffensiveLandThreat)}, us: ${Math.round(this.threatCache.totalAvailableAntiGroundFirepower)}.\nThreat DEFENSIVE: Them ${Math.round(this.threatCache.totalDefensiveThreat)}, us: ${Math.round(this.threatCache.totalDefensivePower)}.\nThreat AIR: Them ${Math.round(this.threatCache.totalOffensiveAirThreat)}, us: ${Math.round(this.threatCache.totalAvailableAntiAirFirepower)}.`}}class Kt{constructor(){this.listeners=new Set}subscribe(t){return this.listeners.add(t),()=>this.listeners.delete(t)}publish(t){this.listeners.forEach((e=>e(t)))}}class Xt extends t.Bot{constructor(t,e,i=[],s=!0){super(t,e),this.tryAllyWith=i,this.enableLogging=s,this.tickOfLastAttackOrder=0,this.logFilePath=null,this.matchAwareness=null,this.eventBus=new Kt,this.missionController=new yt(this.eventBus,((t,e)=>this.logBotStatus(t,e))),this.queueController=new Ot(this.eventBus)}onGameStart(t){const i=t.getTickRate();this.tickRatio=Math.ceil(i/5),this.knownMapBounds=e(t.mapApi);const s=t.getPlayerData(this.name);this.matchAwareness=new zt(null,new h(t.mapApi,this.knownMapBounds),s.startLocation,((t,e)=>this.logBotStatus(t,e))),this.matchAwareness.onGameStart(t,s),this.logBotStatus(`Map bounds: ${this.knownMapBounds.width}, ${this.knownMapBounds.height}`),this.tryAllyWith.filter((t=>t!==this.name)).forEach((t=>this.actionsApi.toggleAlliance(t,!0)))}onGameTick(e){if(!this.matchAwareness)return;const i=this.matchAwareness.getThreatCache();if(e.getCurrentTick()/15%6==0&&this.updateDebugState(e),e.getCurrentTick()%this.tickRatio==0){const s=e.getPlayerData(this.name);this.matchAwareness.onAiUpdate(e,s);const r=e.getVisibleUnits(this.name,"self",(t=>t.isSelectableCombatant)),n=e.getVisibleUnits(this.name,"self",(t=>!!t.deploysInto&&e.getGeneralRules().baseUnit.includes(t.name))),a=e.getVisibleUnits(this.name,"self",(e=>e.type==t.ObjectType.Building&&e.factory!=t.FactoryType.None));0==r.length&&0==a.length&&0==n.length&&(this.logBotStatus(`No army or production left, quitting. ${r}, ${a}, ${n}`),this.actionsApi.quitGame()),this.gameApi.getCurrentTick()%3==0&&this.missionController.onAiUpdate(e,this.productionApi,this.actionsApi,s,this.matchAwareness);const o=this.missionController.getRequestedUnitTypes();this.queueController.onAiUpdate(e,this.productionApi,this.actionsApi,s,i,o,(t=>this.logBotStatus(t)))}}getHumanTimestamp(t){return function(t,e=!1){let i=Math.floor(t/3600);t-=3600*i;let s=Math.floor(t/60);t-=60*s;let r=Math.floor(t);return[...i||!e?[i]:[],v(s,"00"),v(r,"00")].join(":")}(t.getCurrentTick()/15)}logBotStatus(t,e=!1){if(!this.enableLogging)return;const i=this.getHumanTimestamp(this.gameApi),s=`[${i}] ${t}`;this.logger.info(s),e&&this.actionsApi.sayAll(`${i}: ${t}`)}updateDebugState(t){if(!this.getDebugMode())return;const e=t.getPlayerData(this.name),i=t.getVisibleUnits(this.name,"self",(t=>t.harvester)).length;let s=`Cash: ${e.credits} | Harvesters: ${i}\n`;s+=this.queueController.getGlobalDebugText(this.gameApi,this.productionApi),s+=this.missionController.getGlobalDebugText(this.gameApi),s+=this.matchAwareness?.getGlobalDebugText(),this.missionController.updateDebugText(this.actionsApi),t.getVisibleUnits(this.name,"enemy").forEach((t=>{this.actionsApi.setUnitDebugText(t,t.toString())})),this.actionsApi.setGlobalDebugText(s)}onGameEvent(e){e.type===t.ApiEventType.ObjectDestroy&&e.attackerInfo?.playerName==this.name&&(this.tickOfLastAttackOrder+=(this.gameApi.getCurrentTick()-this.tickOfLastAttackOrder)/2)}}const Zt="0.78.0-prvt.6"})(),n})()));